[필드(field)]
필드 : 클래스에 포함된 변수. 객체의 속성값을 지정할 수 있음 (Heap 메모리에 저장 (필드값 미입력시 강제 초기화))
지역 변수(local variable) : 메서드에 포함된 변수 (Stack 메모리에 저장 (지역 변수는 강제 초기화 되지 않음)) 메서드 내부의 지역 변수는 메서드가 호출될 때만 생성. 메서드 실행 완료시 stack 메모리에서 삭제

[메서드(method)]
클래스의 기능에 해당하는 요소

메서드의 정의 :
자바 제어자 리턴(반환) 타입 메서드명(입력 매개 변수) {
// 메서드 내용
}

public(접근 지정자) static(제어자) int(리턴(반환) 타입) sum(메서드명) (int a, int b(입력 매개 변수)) {
// 메서드의 내용
}

리턴(반환) 타입 : 메서드 완료 후 반환되는 타입. 반환값이 있는 경우(=리턴 타입이 void가 아닌 경우) 메서드 내 return이 존재해야 함. 반환값이 없는 메서드는 리턴 타입은 void로 선언

메서드의 이름 : 변수의 이름 규칙과 동일하게 적용

입력 매개 변수 : 메서드에 전달되는 값

메서드 정의시 소괄호(())와 중괄호({})가 포함

리턴 타입이 void인 경우도 메서드 내에 return 사용 가능. 단, 값의 리턴없이 return만 사용 (메서드 종료)

매개 변수가 있는 메서드는 메서드 호출시 매개 변수 선언 및 변수 값 대입을 가장 먼저 수행 (선언과 값 대입이 분리)

static 메서드에서는 static 메서드만 호출 가능

지역 변수는 메서드별로 별도의 공간에 만들어짐. 매개 변수를 전달하면 변수값만 복사되어 전달

매개 변수로 참조 변수가 전달된 경우 번지(위치)값이 전달되어 호출 메서드에서 값 변경시 최초 메서드에서 참조값도 함께 변경

메서드 오버로딩(Overloading) : 컴파일러는 메서드 시그너처(Method signature)가 다르면 이름이 동일하여도 다른 메서드로 인식
// 메서드 시그너처 : 메서드명, 매개 변수 타입
리턴 타입은 시그너처에 포함되지 않아 리턴 타입만 다른 경우 동일 메서드 2개가 정의된 것으로 보아 오류 발생 (함수의 호출시에 리턴 타입이 나타나지 않기 때문에 메서드 시그너처에는 리턴 타입이 포함되지 않음)

메서드의 가변 길이 배열 매개 변수 : 메서드의 매개 변수로 전달된 원소의 개수만큼 배열을 생성하여 사용 (같은 타입일 때 가능)

가변 길이 배열 입력 매개 변수 :
리턴 타입 메서드명 (자료형... 참조 변수) {
}

클래스의 외부에서 메서드/필드 호출 : 객체 생성 → 메서드/필드 호출 (멤버 활용)
같은 클래스 안에 있는 내부 메서드 호출 : 메서드 이름으로 호출 가능 (static의 경우)

[생성자(constructor)]
생성자의 주요 역할 : 객체 생성 및 필드 초기화

생성자의 2가지 특징 : 반드시 클래스명과 동일해야 함. 리턴(반환) 타입이 존재하지 않음
// '리턴 타입이 없다'와 '리턴하지 않는다(void)'는 다름. 생성자는 리턴 타입 자체가 없음

생성자의 문법 구조 :
클래스명(입력 매개 변수) { // 생성자명은 클래스명과 동일. 입력 매개 변수는 생략 가능
}

모든 클래스는 생성자를 포함 (생성자를 정의하지 않는 경우 컴파일러가 기본 생성자 추가)
// 클래스가 붕어빵 기계, 객체가 붕어빵이라고 했을 때, 생성자는 붕어빵을 찍는 기능. 생성자가 없는 클래스는 붕어빵을 찍을 수 없는 붕어빵 기계를 만든 셈. 존재 이유가 없음

생성자를 정의한 경우 → 기본 생성자를 추가 하지 않음 (생성자가 1개 이상 있는 경우 기본 생성자 추가하지 않음)

생성자 내부의 내용은 생성자를 통해 객체 생성 이후의 추가 작업 (주로 필드 초기화)

생성자도 오버로딩(Overloading) 가능 (생성자가 3개 → 객체 생성 방법 3개)

[this 키워드]
자신이 속한 클래스의 객체

모든 필드와 메서드 활용시에는 소속과 함께 표기해야 함 (정의식에서는 사용하지 않음)
클래스 내부의 필드와 메서드에 소속을 표기하지 않는 경우 컴파일러가 자동으로 소속(this.)을 불여 줌 (모든 필드와 메서드 활용시 컴파일러가 this.을 자동으로 붙임)

static 메서드 내에서는 this 키워드를 사용할 수 없음

지역 변수에는 this.가 붙지 않음

필드는 클래스 내부 전체 영역에서 사용 가능
지역 변수는 해당 메서드 내부에서만 사용 가능
필드와 지역 변수 모두를 사용 가능한 영역에서는 지역 변수로 인식

[this() 메서드]
자기 클래스 내부의 다른 생성자를 호출

this() 메서드는 생성자 내부에서만 사용 가능
반드시 중괄호 이후 첫 줄에 위치하여야 함

this() 메서드의 활용 예 → 생성자에서 여러 개의 변수를 초기화 하는 경우. this() 메서드를 이용하여 생성자의 중복성 제거

[중첩 클래스(Nested class)]
중첩 클래스란 클래스 내부에 선언한 클래스를 말하는데, 중첩 클래스를 사용하면 클래스의 멤버를 쉽게 사용할 수 있고 외부에는 중첩 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있음. 중첩 클래스는 선언하는 위치에 따라 두 가지로 분류됨. 클래스의 멤버로서 선언되는 중첩 클래스를 멤버 클래스라고 하고 메서드 내부에서 선언되는 중첩 클래스를 로컬 클래스라고 함

선언 위치에 따른 분류 / 선언 위치 / 객체 생성 조건
멤버 클래스 /
인스턴스 멤버 클래스 /
class A {
class B {}
} // A 객체를 생성해야만 B 객체를 생성할 수 있음

멤버 클래스 /
정적 멤버 클래스 /
class A {
static class B {}
} // A 객체를 생성하지 않아도 B 객체를 생성할 수 있음

로컬 클래스 /
class A {
void method() {
class B {
}
}
} // method가 실행할 때만 B 객체를 생성할 수 있음

중첩 클래스도 하나의 클래스이기 때문에 컴파일하면 바이트코드 파일(.class)이 별도로 생성됨. 멤버 클래스일 경우 바이트코드 파일의 이름은 다음과 같이 결정됨
A $ B .class
바깥 클래스 $ 멤버 클래스 .class

로컬 클래스일 경우에는 다음과 같이 $1이 포함된 바이트코드 파일이 생성된다.
A $1 B .class
바깥 클래스 $1 로컬 클래스 .class