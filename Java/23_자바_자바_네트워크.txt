[IP 주소(Internet Protocol Address)]
인터넷 상에서 장치간 통신을 위해 장치를 식별하는 주소

IPv4 :
현재 일반적으로 사용되는 주소로 32 bit 구성 (약 43억개)
[0-255]. [0-255]. [0-255]. [0-255]와 같이 10진수 4개를 .으로 구분하여 표기 (예. 192.168.0.2)
특정 IP는 특별 용도로 예약되어 사용 (예. 127.0.0.1(로컬 호스트(루프백) 주소))

IPv6 :
IPv4에서의 IP 부족 현상을 해결하기 위한 방법으로 128 bit(16 byte)로 구성 (43억 * 43억 * 43억 * 43억)
[0000-FFFF]:[0000-FFFF]:[0000-FFFF]:[0000-FFFF]:[0000-FFFF]:[0000-FFFF]:[0000-FFFF]:[0000-FFFF]와 같이 4자리 16진수(16 bit) 8개를 콜론(:)으로 연결하여 표기 (예. 200F:02AB:A038:FF09:200F:02AB:A038:FF09)
340,282,366,920,938,463,463,374,607,431,768,211,456가지수

[IP 주소의 분류]
A 클래스
NetID (1 byte) / HostID (3 byte)
0□□□□□□□.■■■■■■■■.■■■■■■■■■.■■■■■■■■

NetID
네트워크 주소의 범위 : [0-127]
할당 가능 네트워크 수 : 128
HostID
호스트 주소의 범위 : [0-255].[0-255].[0-255]
할당 가능 호스트의 수 : 256 * 256 * 256 - 2 = 16,777,214
(-2 → 가능 범위의 첫번째 주소 : network주소 (전부 0) / 마지막 주소 : broadcast 주소 (전부 1))

B 클래스
NetID (2 byte) / HostID (2 byte)
10□□□□□□.□□□□□□□□.■■■■■■■■.■■■■■■■■
NetID (1 byte) / HostID (3 byte)
0□□□□□□□.■■■■■■■■.■■■■■■■■■.■■■■■■■■

NetID
네트워크 주소의 범위 : [128-191].[0-255]
할당 가능 네트워크 수 : 64 * 256 = 16,384
HostID
호스트 주소의 범위 : [0-255].[0-255]
할당 가능 호스트의 수 : 256 * 256 - 2 = 65,534

C 클래스
NetID (3 byte) / HostID (1 byte)
110□□□□□.□□□□□□□□.■■■■■■■■.■■■■■■■■
NetID (1 byte) / HostID (3 byte)
0□□□□□□□.■■■■■■■■.■■■■■■■■■.■■■■■■■■

NetID
네트워크 주소의 범위 : [192-223].[0-255].[0-255]
할당 가능 네트워크 수 : 32 * 256 * 256 = 2,097,152
HostID
호스트 주소의 범위 : [0-255]
할당 가능 호스트의 수 : 256 - 2 = 254

[서브넷 마스크]
네트워크 ID(NetID)와 호스트 ID(HostID)를 구분하는 마스크
IP 주소 & 서브넷 마스크 = 네트워크 ID
예. IP(128.123.222.123), Subnet Mask(255.255.0.0) → NetID = 128.123.0.0

하나의 네트워크를 다시 여러 서브 네트워크로 변환하는 경우에도 사용

B 클래스 하나를 할당
NetID / HostID (호스트 : 65,536 - 2)
10□□□□□□.□□□□□□□□.■■■■■■■■■.■■■■■■■■
4개의 서브 네트워크를 구성
11111111.11111111.11000000.00000000 -> (255.255.192.0)
¼의 호스트를 가질 수 있는 4개의 서브 네트워크 구성
10□□□□□□.□□□□□□□□.00 (00 : SubnetID)■■■■■■■.■■■■■■■■ 호스트 : 16,384 - 2
10□□□□□□.□□□□□□□□.01 (01 : SubnetID)■■■■■■■.■■■■■■■■ 호스트 : 16,384 - 2
10□□□□□□.□□□□□□□□.10 (10 : SubnetID)■■■■■■■.■■■■■■■■ 호스트 : 16,384 - 2
10□□□□□□.□□□□□□□□.11 (11 : SubnetID)■■■■■■■.■■■■■■■■ 호스트 : 16,384 - 2

공인 IP :
인터넷 상에 서로 다른 장치들 간의 유일한 식별에 사용되는 IP
나라별 별도의 기관에서 관리하며 한국은 인터넷진흥원에서 관리

사설 IP :
내부망 내에서만 한정적으로 사용되는 IP
내부에서만 사용되기 때문에 네트워크별로 중복 가능

A 클래스 : 10.[0-255].[0-255].[0-255]
B 클래스 : 172.[16-31].[0-255].[0-255]
C 클래스 : 192.168.[0-255].[0-255]

D 클래스
NetID
1110□□□□.□□□□□□□□.□□□□□□□□.□□□□□□□□
멀티캐스트 주소 (224.0.0.0 ~ 239.255.255.255)

E 클래스
NetID
1111□□□□.□□□□□□□□.□□□□□□□□.□□□□□□□□
향후 사용을 위해 예약

[포트(Port)]
호스트 내에서 실행되고 있는 프로세스를 구분하기 위한 16비트의 논리적 할당 (0~65535)
호스트의 IP가 집주소에 해당하는 개념이라면 Port는 방번호에 해당
호스트의 IP가 컴퓨터를 찾기 위한 정보라면 Port는 프로그램에 해당 (어떤 프로그램이 사용하는 정보인지)

포트번호 : 0~1023
잘 알려진 포트(well-known-port)로 대표적인 인터넷 프로그램이 미리 예약하여 사용하는 포트

포트 / 서비스
20 / FTP-Data / FTP
21 / FTP-Control / FTP
23 / Telnet / 원격 터미널
25 / SMTP-mail / 메일
53 / DNS / 도메인이름 → IP주소
69 / TFTP / 간단한 FTP
80 / HTTP / Web
110 / POP3 / 메일
111 / RPC / 원격 프로시져 콜
138 / NetBIOS / 윈도우 파일 공유
143 / IMAP / 메일
161 / SNMP / 네트워크 관리

[TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)]
TCP(Transmission Control Protocol) :
신뢰성이 높음 (오류시 재전송)
연결형 프로토콜 : 통신 과정에서 연결 유지 필요 (통신 상태가 많은 경우 시스템 부하가 높음)
전송 데이터 크기는 제한이 없음
파일 전송과 같이 신뢰성이 필요한 서비스에 주로 사용
전화 통신과 유사한 개념

UDP(User Datagram Protocol) :
신뢰성이 낮음 (오류시 또는 미전달시 데이터그램(전달 데이터) 삭제)
비연결형 프로토콜 : 통신 과정에서 연결 유지 불필요 (통신 상대가 많아도 시스템 부하가 낮음)
전송 데이터의 크기는 65,536 바이트(헤더 포함)로 초과시 나누어 전송
실시간성과 같은 성능이 중요한 서비스에 주로 사용
우편(소포) 통신과 유사한 개념

TCP / UDP
신뢰성 : 높음 / 낮음
연결방식 : 연결 지향 / 비연결 지향
패킷 교환 방식 : 가상 회선 방식 / 데이터그램 방식
전송 순서 : 전송 순서 보장 / 전송 순서 비보장
수신 여부 확인 : 수신 여부 확인 / 수신 여부 미확인
통신 방식 : 1:1통신 / 1:1 또는 1:N 또는 N:N
속도 : 상대적으로 느림 / 상대적으로 빠름

[1:1 통신과 1:N 통신]
유니캐스팅(Unicasting) :
두 장치간 1:1 통신 방식 (특정 장치의 주소를 지정하여 통신)
물리주소(MAC 주소)를 기반으로 통신 (자신의 물리 주소가 아닌 패킷이 도착하면 프레임을 버림)
동일한 내용을 여러 사용자에게 보내고자 하는 경우 비효율적임

브로드캐스팅(Broadcasting) :
UDP 기반 호스트가 속해 있는 네트워크 내의 모든 장치에 패킷을 전달하는 1:N 통신 방식
라우터의 설정에 따라 라우터를 경유하지 못할 수도 있으며 주로 내부 네트워크에만 한정
동일한 내용을 여러 사용자에게 보내고자 하는 경우 효율적임
브로드캐스트 주소
: (모든 HostID = 1) : NetID + 11... 또는 NetID + SubnetID + 11...
→ 해당 네트워크 또는 서브넷의 모든 장치에 전달 (단, 라우터가 브로드캐스트를 지원해야 함)
: (모든 IP = 1) : 255.255.255.255
→ 호스트가 속한 네트워크의 모든 장치에 전달

멀티캐스팅(Multicasting) :
특정 장치들이 데이터를 전달하는 1:N 통신 방식
실제 호스트 주소가 아닌 가상 D 클래스 IP 주소에 가입된 호스트에게 데이터 전달
D 클래스 IP 주소 [224-239].[0-255].[0-255].[0-255]
필요성 : 예) 네트워크 내 자신을 포함하여 6개의 단말이 있고 이 중 3개의 단말에 동일 데이터를 전송하고자 하는 경우
유니캐스트로 보내는 경우 → 3번 반복해야 함
브로드캐스트로 보내는 경우 → 2 호스트가 필요없이 받음

[InetAddress]
IP 주소(호스트 이름) 저장 및 관리 클래스 (Port 번호 관리 못함)

InetAddress 객체 생성 :
정적(static) 메서드를 사용하여 객체 생성

리턴 타입 / 메서드명 / 주요 내용
InetAddress / getByName(String host) / Host 이름과 해당 IP 주소 저장 객체 리턴
InetAddress / getByAddress(byte[] addr) / 입력 IP 주소 저장 객체 리턴 (128 이상의 경우 (byte) 캐스팅 필요)
InetAddress / getByAddress(String host, byte[] addr) / Host 이름과 입력 IP 주소 저장 객체 리턴 (IP 주소가 128 이상의 경우 (byte) 타입으로 캐스팅 필요)
InetAddress / getLocalHost() / 로컬 호스트 IP 저장 객체 리턴
InetAddress / getLoopbackAddress() / 루프백(loopback) IP(127.0.0.1) 저장 객체 리턴
InetAddress[] / getAllByName(String host) / 여러 개의 IP를 사용하는 경우 모든 host IP 저장 객체 리턴
getByName(.)으로 생성하는 경우 : InetAddress는 호스트 이름 + IP 주소 저장 ((객체를 만드는 시점에) 실제 호스트 이름이 DNS에 정확히 있어야 함(없으면 예외발생))
getByAddress(byte[])로 생성하는 경우 : IP주소 저장 ((객체를 만드는 시점에) 실제 정확한 IP인지는 중요하지 않음)
getByAddress(String, byte[])로 생성하는 경우 : 호스트의 이름 + IP주소 저장 ((객체를 만드는 시점에) 실제 정확한 호스트 이름인지는 중요하지 않음)

InetAddress 주요 메서드 :
리턴 타입 / 메서드명 / 주요 내용
byte[] / byte[] getAddress() / InetAddress 객체가 저장하고 있는 IP 주소를 byte[]로 리턴 (-128~127 사이의 값)
String / String getHostAddress() / InetAddress 객체가 저장하고 있는 IP 주소를 문자열로 리턴 (0~255 사이의 값)
String / String getHostName() / InetAddress 객체가 저장하고 있는 호스트의 이름을 문자열로 리턴
boolean / isLoopbackAddress() / IP가 루프백(loopback) 주소인지 여부 확인
boolean / isMulticastAddress() / IP가 멀티캐스팅 영역의 주소인지 여부 확인
booolean / isReachable(int timeout) / Ping 명령으로 리턴 여부 확인 (cmd 창 : ping www.google.com)

import java.io.IOException;
import java.net.InetAddress;
import java.util.Arrays;

public class InetAddressObjectAndMethod {
public static void main(String[] args) throws IOException {

// 1. InetAddress 객체 생성
// 1-1. 원격지 IP 객체 생성
InetAddress ia1 = InetAddress.getByName("www.google.com");
InetAddress ia2 = InetAddress.getByAddress(new byte[] { (byte) 142, (byte) 251, (byte) 221, 68 });
InetAddress ia3 = InetAddress.getByAddress("www.google.com",
new byte[] { (byte) 142, (byte) 251, (byte) 221, 68 });

System.out.println(ia1);
System.out.println(ia2);
System.out.println(ia3);
System.out.println();

// 1-2. 로컬 / 루프백 IP
InetAddress ia4 = InetAddress.getLocalHost();
InetAddress ia5 = InetAddress.getLoopbackAddress();

System.out.println(ia4);
System.out.println(ia5);
System.out.println();

// 1-3. 하나의 호스트가 여러개의 IP를 가지고 있는 경우
InetAddress[] ia6 = InetAddress.getAllByName("www.naver.com");
System.out.println(Arrays.toString(ia6));
System.out.println();

// 2. InetAddress 메서드
// 2-1.호스트와 IP 알아내기
byte[] address = ia1.getAddress();
System.out.println(Arrays.toString(address));
System.out.println(ia1.getHostAddress());
System.out.println(ia1.getHostName());
System.out.println();

// 2-2. 저장 주소의 특징 알아내기
System.out.println(ia1.isReachable(1000)); // true
System.out.println(ia1.isLoopbackAddress()); // false
System.out.println(ia1.isMulticastAddress()); // false 224-239.0-255.0-255.0-255
System.out.println(InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 }).isLoopbackAddress()); // true
System.out.println(InetAddress.getByAddress(new byte[] { (byte) 225, (byte) 225, (byte) 225, (byte) 225 })
.isMulticastAddress()); // true
}
}

[SocketAddress]
IP 주소(호스트이름) + Port 번호 관리하는 추상 클래스 = InetAddress + Port 번호

SocketAddress 객체 생성 :
SocketAddress의 하위 클래스인 InetSocketAddress의 생성자로 객체 생성

SocketAddress
↑
InetSocketAddress

생성자 :
InetSocketAddress(int port) / IP주소 없이 내부의 포트 정보만 지정
InetSocketAddress(String hostname, int port) / 매개 변수의 호스트의 이름에 해당하는 IP와 포트 번호를 지정
InetSocketAddress(InetAddress addr, int port) / 매개 변수의 InetAddress(IP 정보)와 포트 번호를 지정

InetSocketAddress 주요 메서드 :
리턴 타입 / 메서드명
InetAddress / getAddress() / 저장 IP 주소를 InetAddress 타입으로 리턴
String / getHostName() / 호스트의 이름을 문자열로 리턴
int / getPort() / 포트 번호를 정수형으로 리턴

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;

public class SocketAddressObjectAndMethod {
public static void main(String[] args) throws UnknownHostException {

// 1. SockstAddress 객체 생성 (InetSocketAddress 생성자 사용)
InetAddress ia = InetAddress.getByName("www.google.com");
int port = 10000;
InetSocketAddress isa1 = new InetSocketAddress(port);
InetSocketAddress isa2 = new InetSocketAddress("www.google.com", port);
InetSocketAddress isa3 = new InetSocketAddress(ia, port);

System.out.println(isa1);
System.out.println(isa2);
System.out.println(isa3);
System.out.println();

// 2. SocketAddress의 메서드
System.out.println(isa2.getAddress());
System.out.println(isa2.getHostName());
System.out.println(isa2.getPort());
}
}

[TCP(Transmission Control Protocol) 통신]
TCP 통신 메커니즘 → 신뢰성이 높은 연결 지향성 프로토콜

Server
ServerSocket
① ↑
② (Socket) ③ ↔ (Socket) Client
④ ↑
⑤ (Socket) ⑥ ↔ (Socket) Client

번호 / 동작
1, 4 / Client의 Socket으로 Server의 ServerSocket에 접속
2, 5 / Server는 각 Client와 통신할 수 있는 Socket 생성
3, 6 / Server와 Client의 Socket간의 통신
// 두 호스트 간의 통신을 위해서는 두 호스트를 각각 server와 client로 구성하여 통신
// 다수 Client간의 통신을 위해서는 Server를 공유하여 client - server - client 간 통신

[Socket]
TCP 통신에서 두 호스트간 입출력 스트림을 제공(실제 통신 객체)하는 클래스

Socket 객체 생성 :
객체의 생성과 동시에 연결 요청 // UnknownHostException과 IOException 처리 필요

생성자 / 동작
Socket() / 특정 주소에 연결 없이 통신을 위한 소켓 생성
Socket(String host, int port) / 매개 변수로 입력되는 원격지 host 주소(문자열)의 port에 연결하는 소켓 생성 (생성과 동시에 연결 요청)
Socket(String host, int port, InetAddress localAddr, int localPort) / 매개 변수로 입력되는 원격지 host 주소(문자열)의 port에 연결하는 소켓 생성. 송신지의 InetAddress와 송신지 port 정보를 포함하여 연결 요청
Socket(InetAddress address, int port) / 매개 변수로 입력되는 원격지 host 주소(InetAddress)의 port에 연결하는 소켓 생성 (생성과 동시에 연결 요청)
Socket(InetAddress address, int port, InetAddress localAddr, int localPort) / 매개 변수로 입력되는 원격지 host 주소(InetAddress)의 port에 연결하는 소켓 생성. 송신지의 InetAddress와 송신지 port 정보를 포함하여 연결 요청

Socket 주요 메서드 :
리턴 타입 / 메서드명 / 동작
void / connect(SocketAddress endpoint) / 연결 정보가 없는 소켓에 원격지 주소 정보(SocketAddress) 제공하여 timeout 시간동안 연결 요청 수행 (timeout=0 인 경우 시간 제약 없음) (IOException 처리 필요)
void / connect(SocketAddress endpoint, int timeout) / 연결 정보가 없는 소켓에 원격지 주소 정보(SocketAddress) 제공하여 timeout 시간동안 연결 요청 수행 (timeout=0 인 경우 시간 제약 없음) (IOException 처리 필요)
InetAddress / getInetAddress() / 원격지 주소 정보 : Socket에 연결된 원격지 InetAddress와 port 리턴
int / getPort() / 원격지 주소 정보 : Socket에 연결된 원격지 InetAddress와 port 리턴
InetAddress / getLocalAddress() / 로컬 주소 정보 : 로컬의 InetAddress와 port 정보 및 두 가지 정보를 모두 포함한 SocketAddress 리턴
int / getLocalPort() / 로컬 주소 정보 : 로컬의 InetAddress와 port 정보 및 두 가지 정보를 모두 포함한 SocketAddress 리턴
SocketAddress / getLocalSocketAddress() / 로컬 주소 정보 : 로컬의 InetAddress와 port 정보 및 두 가지 정보를 모두 포함한 SocketAddress 리턴
InputStream / getInputStream() / 입출력 스트림 : 원격지와의 통신을 위한 입출력 스트림 리턴
OutputStream / getOutputStream() / 입출력 스트림 : 원격지와의 통신을 위한 입출력 스트림 리턴
int / getSendBufferSize() / 송수신 버퍼 사이즈 : 송수신 버퍼 사이즈의 설정 및 읽기 (default : 65536) (SocketException 처리 필요)
void / setSendBufferSize(int size) / 송수신 버퍼 사이즈 : 송수신 버퍼 사이즈의 설정 및 읽기 (default : 65536) (SocketException 처리 필요)
int / getReceiveBufferSize() / 송수신 버퍼 사이즈 : 송수신 버퍼 사이즈의 설정 및 읽기 (default : 65536) (SocketException 처리 필요)
void / setReceiveBufferSize(int size) / 송수신 버퍼 사이즈 : 송수신 버퍼 사이즈의 설정 및 읽기 (default : 65536) (SocketException 처리 필요)

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class SocketObject {
public static void main(String[] args) throws UnknownHostException, IOException {

// 1. Socket 객체 생성
Socket socket1 = new Socket();
Socket socket2 = new Socket("www.naver.com", 80);
Socket socket3 = new Socket("www.naver.com", 80, InetAddress.getLocalHost(), 10000);
Socket socket4 = new Socket(InetAddress.getByName("www.naver.com"), 80);
Socket socket5 = new Socket(InetAddress.getByName("www.naver.com"), 80, InetAddress.getLocalHost(), 20000);

// 2. Socket 메서드
// Connect 메서드 / 원격지 주소 정보 제공
System.out.println(socket1.getInetAddress() + ":" + socket1.getPort());
socket1.connect(new InetSocketAddress("www.naver.com", 80));
System.out.println(socket1.getInetAddress() + ":" + socket1.getPort());
System.out.println(socket2.getInetAddress() + ":" + socket2.getPort());
System.out.println();

// 로컬 주소 정보 (지정한 경우 + 지정하지 않은 경우)
System.out.println(socket2.getLocalAddress() + ":" + socket2.getLocalPort());
System.out.println(socket2.getLocalSocketAddress());

System.out.println(socket3.getLocalAddress() + ":" + socket3.getLocalPort());
System.out.println(socket3.getLocalSocketAddress());
System.out.println();

// send/receive 버퍼 사이즈
System.out.println(socket2.getSendBufferSize() + "," + socket2.getReceiveBufferSize());
}
}

[ServerSocket]
TCP 통신에서 Socket으로부터의 연결 요청을 수락하는 서버 역할의 클래스

ServerSocket 객체 생성 (IOException 처리 필요) :
생성자 / 동작
ServerSocket() / 특정 포트 바인딩(bind) 없이 단순히 ServerSocket 객체만을 생성 (이후 binding 필요)
ServerSocket(int port) / 매개 변수로 입력된 port로 바인딩 된 ServerSocket 객체 생성 (이후 ServerSocket으로의 연결 요청이 오면 바인딩 된 port로 전달)
// Binding은 수신 호스트에서 연결 요청이 들어온 경우 해당 데이터를 전달할 연결 포트를 지정
Connect는 원격지 특정 주소로의 연결을 수행

ServerSocket의 주요 메서드 :
리턴 타입 / 메서드명 / 동작
void / bind(SocketAddress endpoint) / 바인딩 정보가 없는 서버 소켓에 바인딩 정보를 제공
boolean / isBound() / 바인딩 여부 확인 : ServerSocket이 바인딩 되어 있는지의 여부를 리턴
void / setSoTimeout(int timeout) / 연결 요청 리스닝 시간 : Socket으로부터의 연결 요청을 리스닝(listening)하는 시간의 설정 및 가져오기 (timeout=0 이면 무한 대기)
int / getSoTimeout() / 연결 요청 리스닝 시간 : Socket으로 부터의 연결 요청을 리스닝(listening)하는 시간의 설정 및 가져오기 (timeout=0 이면 무한 대기)
Socket / accept() / 연결 요청 수락 : 연결 요청이 수락 된 후 통신을 위한 Socket 객체 리턴 (연결 수락까지 설정된 timeout 시간만큼 blocking)

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;

public class SocketExample {
public static void main(String[] args) {

// 1. Socket 객체 생성
Socket socket1 = new Socket();
Socket socket2 = null;
Socket socket3 = null;
Socket socket4 = null;
Socket socket5 = null;

try {
socket2 = new Socket("www.naver.com", 80);
socket3 = new Socket("www.naver.com", 80, InetAddress.getLocalHost(), 10000);
socket4 = new Socket(InetAddress.getByName("www.naver.com"), 80);
socket5 = new Socket(InetAddress.getByName("www.naver.com"), 80, InetAddress.getLocalHost(), 10000);
} catch (UnknownHostException e) {
} catch (IOException e) {
}

// 2. Socket 메서드
// connect 원격지 주소 정보
System.out.println(socket1.getInetAddress() + ":" + socket1.getPort()); // null
try {
socket1.connect(new InetSocketAddress("www.naver.com", 80));
} catch (IOException e) {
}
System.out.println(socket1.getInetAddress() + ":" + socket1.getPort());
System.out.println(socket2.getInetAddress() + ":" + socket2.getPort());
System.out.println();

// 로컬 주소 정보 (로컬 주소 정보를 지정하지 않은 경우 + 지정한 경우
System.out.println(socket2.getLocalAddress() + ":" + socket2.getLocalPort());
System.out.println(socket2.getLocalSocketAddress());
System.out.println(socket3.getLocalAddress() + ":" + socket3.getLocalPort());
System.out.println(socket3.getLocalSocketAddress());
System.out.println();

// send/receive 버퍼 사이즈
try {
System.out.println(socket2.getSendBufferSize() + ", " + socket2.getReceiveBufferSize()); // 65536, 65536
} catch (SocketException e) {
}
}
}

TCP 통신 Server_Client간 Text 전송 예제 (ClientSide) :
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class TCP_Text_ClientSide {
public static void main(String[] args) {

System.out.println("<<Client>>");
try {
Socket socket = new Socket(InetAddress.getByName("localhost"), 10000);
System.out.println("Server에 접속 완료");
System.out.println("접속 Server 주소 : " + socket.getInetAddress() + ":" + socket.getPort());

DataInputStream dis = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));

dos.writeUTF("안녕하세요");
dos.flush();
String str = dis.readUTF();
System.out.println("server : " + str);

} catch (UnknownHostException e) {
} catch (IOException e) {
e.printStackTrace();
}
}
}

TCP 통신 Server_Client간 Text 전송 예제 (ServerSide) :
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class TCP_Text_ServerSide {
public static void main(String[] args) {

System.out.print("<<Server>>");
ServerSocket serverSocket = null;
try {
serverSocket = new ServerSocket(10000);
} catch (IOException e) {
System.out.println("해당 포트를 열 수 없습니다.");
System.exit(0); // 프로그램 종료
}

System.out.println(" - Client 접속 대기...");
try {
Socket socket = serverSocket.accept();

System.out.println("Client 연결 수락");
System.out.println("접속 Client 주소 : " + socket.getInetAddress() + ":" + socket.getPort());

DataInputStream dis = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));

String str = dis.readUTF();
System.out.println("client : " + str);
dos.writeUTF("어서오세요");
dos.flush();

} catch (IOException e) {
e.printStackTrace();
}
}
}

TCP 통신 Server_Client File간 전송 예제 (ClientSide) :
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class TCP_File_ClientSide {
public static void main(String[] args) {

System.out.println("<<Client>>");
try {
Socket socket = new Socket(InetAddress.getByName("localhost"), 10000);
System.out.println("Server에 접속 완료");
System.out.println("접속 Server 주소 : " + socket.getInetAddress() + ":" + socket.getPort());

DataInputStream dis = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));

File file = new File("src/sec02_tcpcommunication/files_client/javatest_cat.jpg");

FileInputStream fis = new FileInputStream(file);
BufferedInputStream bis = new BufferedInputStream(fis);
System.out.println("파일 전송 : " + file.getName());

// 1. 파일 이름 전송
dos.writeUTF(file.getName());

// 2. 파일 데이터 전송
byte[] data = new byte[2048];
int len;
while ((len = bis.read(data)) != -1) {
dos.writeInt(len); // 읽은 데이터의 길이
dos.write(data, 0, len); // 전송 데이터
dos.flush();
}
dos.writeInt(-1);
dos.flush();

String str = dis.readUTF();
System.out.println(str);

} catch (UnknownHostException e) {
} catch (IOException e) {
e.printStackTrace();
}
}
}

TCP 통신 Server_Client간 File 전송 예제 (ServerSide) :
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class TCP_File_ServerSide {
public static void main(String[] args) {

System.out.print("<<Server>>");
ServerSocket serverSocket = null;
try {
serverSocket = new ServerSocket(10000);
} catch (IOException e) {
System.out.println("해당 포트를 열 수 없습니다.");
System.exit(0); // 프로그램 종료
}

System.out.println(" - Client 접속 대기...");
try {
Socket socket = serverSocket.accept();

System.out.println("Client 연결 수락");
System.out.println("접속 Client 주소 : " + socket.getInetAddress() + ":" + socket.getPort());

DataInputStream dis = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));

// 전송받은 파일 이름 출력
String receivedFileName = dis.readUTF();
System.out.println("파일수신 : " + receivedFileName);

File file = new File("src/sec02_tcpcommunication/files_server/" + receivedFileName);

FileOutputStream fos = new FileOutputStream(file);
BufferedOutputStream bos = new BufferedOutputStream(fos);

byte[] data = new byte[2048];
int len;
while ((len = dis.readInt()) != -1) {
dis.read(data, 0, len);
bos.write(data, 0, len);
bos.flush();
}
System.out.println("파일 수신 완료");
dos.writeUTF("파일 전송 완료");
dos.flush();

} catch (IOException e) {
e.printStackTrace();
}
}
}

[UDP(User Datagram Protocol) 통신]
UDP 통신 매커니즘 → 비연결 지향성 프로토콜

Client A
(Data)
① ↓
DatagramPacket
(Data)
② ↓
DatagramSocket
DatagramPacket
(Data)
↓
Network
③ ↓
DatagramSocket
DatagramPacket
(Data)
④ ↓
DatagramPacket
(Data)
↓
Client B
(Data)

번호 / 동작
1 / 보낼 데이터를 DatagramPacket에 담기 (최대 65508 bytes = 65536 - 20(IP header) - 8(UDP header))
2 / DatagramPacket을 DatagramSocket으로 전송 (DatagramSocket의 send())
3 / DatagramSocket으로 부터 DatagramPacket 꺼내기 (DatagramSocket의 receive()) (수신시에는 비어있는 DatagramPacket을 하나 만들어 옮겨 담는 개념 : 수신한 DatagramSocket.receive (비어있는 DatagramPacket))
4 / DatagramPacket으로 부터 Data 꺼내기
// 보내고자 하는 데이터의 크기가 65508보다 큰 경우 여러 개의 DatagramPacket으로 나누어 전송

송신 매커니즘 :
Data
↓
로컬 정보 없음
DatagramPackekt
(Data)
↓
로컬 정보(IP/Port)
↓ bind()
DaragramSocket
(DatagramPacket)
↓
수신지
DaragramSocket

// 송신지 DatagramSocket.connect(수신지 DatagramSocket)
송신지
DatagramSocket
(DatagramSocket)
↓
수신지
DatagramSocket
(DatagramSocket)

수신지 정보 포함 → 수신지 정보 포함
DatagramPacket 및 DatagramSocket에 연결된 수신지 주소로 전송 (이때 반드시 DatagramPacket의 주소 = DatagramSocket 연결 주소. 불일치시 IllegalArgumentException)

수신지 정보 포함 → 수신지 정보 미포함
DatagramPacket에 포함된 주소로 전송 (비연결 지향성) (DatagramSocket의 send())

수신지 정보 미포함 → 수신지 정보 포함
DatagramSocket에 연결(connect)되어 있는 수신지 주소로 전송 (원격지 주소 연결 : DatagramSocket의 connect() + DatagramSocket의 send())

수신지 정보 미포함 → 수신지 정보 미포함
전송 불가(NullPointerException)

수신 매커니즘 :
송신지
DatagramSocket
↓
로컬 정보(IP/Port)
↓ bind
DatagramSocket
(DatagramPacket)
↓ .receive ⓐ DatagramPacket(ⓑ 비어있는 DatagramPacket)
DatagramPacket
(Data)
ⓒ ↓
(Data)

번호 / 동작
ⓐ / 비어있는 DatagramPacket 생성 (최대 65508 bytes = 65536 - 20(IP header) - 8(UDP header))
ⓑ / 수신한 DatagramPacket이 비어있는 DatagramPacket으로 복사 (DatagramSocket의 receive(비어있는 DatagramPacket))
ⓒ / 수신 DatagramPacket으로 부터 데이터 추출 (DatagramPacket의 getData(), getOffset(). getLength())

DatagramPacket 객체 생성 (byte[]의 데이터를 포함) :
생성자 / 동작
DatagramPacket(byte[] buf, int length) / 주소 없이 단순히 데이터만 저장하는 패킷 (일반적으로 수신측에서 수신한 패킷을 저장하는데 사용) // buf[] : 데이터 바이트 배열, offset : 시작 오프셋, length : 데이터의 길이
DatagramPacket(byte[] buf, int offset, int length) / 주소 없이 단순히 데이터만 저장하는 패킷 (일반적으로 수신측에서 수신한 패킷을 저장하는데 사용) // buf[] : 데이터 바이트 배열, offset : 시작 오프셋, length : 데이터의 길이
DatagramPacket(byte[] buf, int length, InetAddress address, int port) / 데이터의 정보에 추가하여 수신측 주소 정보를 InetAddress와 port 번호로 추가한 패킷 (소포 포장지에 주소를 써 놓는 개념) // buf[] : 데이터 바이트 배열, offset : 시작 오프셋, length : 데이터의 길이
DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) / 데이터의 정보에 추가하여 수신측 주소 정보를 InetAddress와 port 번호로 추가한 패킷 (소포 포장지에 주소를 써 놓는 개념) // buf[] : 데이터 바이트 배열, offset : 시작 오프셋, length : 데이터의 길이
DatagramPacket(byte[] buf, int length, SocketAddress address) / 데이터의 정보에 추가하여 수신측 주소 정보를 SocketAddress(InetAddress + Port)로 추가한 패킷 (소포 포장지에 주소를 써 놓는 개념) // buf[] : 데이터 바이트 배열, offset : 시작 오프셋, length : 데이터의 길이
DatagramPacket(byte[] buf, int offset, int length, SocketAddress address) / 데이터의 정보에 추가하여 수신측 주소 정보를 SocketAddress(InetAddress + Port)로 추가한 패킷 (소포 포장지에 주소를 써 놓는 개념) // buf[] : 데이터 바이트 배열, offset : 시작 오프셋, length : 데이터의 길이

DatagramPacket 주요 메서드 :
리턴 타입 / 메서드명 / 동작
InetAddress / getAddress() / 원격지 IP주소 읽기 및 설정 : InetAddress 타입으로 설정된 수신지 주소 읽기 및 쓰기 (수신지 주소가 없는 경우 getAddress()는 null을 리턴)
void / setAddress(InetAddress iaddr) / 원격지 IP주소 읽기 및 설정 : InetAddress 타입으로 설정된 수신지 주소 읽기 및 쓰기 (수신지 주소가 없는 경우 getAddress()는 null을 리턴)
int / getPort() / 원격지 Port 읽기 및 설정 : int 타입으로 설정된 수신지 포트 읽기 및 쓰기 (수신지 포트가 없는 경우 getPort()는 -1을 리턴)
void / setPort(int iport) / 원격지 Port 읽기 및 설정 : int 타입으로 설정된 수신지 포트 읽기 및 쓰기 (수신지 포트가 없는 경우 getPort()는 -1을 리턴)
SocketAddress / getSocketAddress() / 원격지 SocketAddress 읽기 및 설정 : SocketAddress 타입으로 설정된 수신지 IP와 Port 읽기 및 쓰기 (수신지 SocketAddress가 없는 경우 IllegalArgumentException)
void / setSocketAddress(SocketAddress address) / 원격지 SocketAddress 읽기 및 설정 : SocketAddress 타입으로 설정된 수신지 IP와 Port 읽기 및 쓰기 (수신지 SocketAddress가 없는 경우 IllegalArgumentException)
byte[] / getData() / 패킷에 포함되는 데이터 읽기 및 설정 : byte[] 타입으로 패킷에 포함된 데이터를 읽기 및 쓰기, 이때 getData()의 리턴값은 offset, length와 관계 없이 buf값 리턴 (패킷당 전송가능한 최대 raw 데이터 = 65,508 bytes)
void / setData(byte[] buf) / 패킷에 포함되는 데이터 읽기 및 설정 : byte[] 타입으로 패킷에 포함된 데이터를 읽기 및 쓰기, 이때 getData()의 리턴값은 offset, length와 관계 없이 buf값 리턴 (패킷당 전송가능한 최대 raw 데이터 = 65508 bytes)
void / setData(byte[] buf, int offset, int length) / 패킷에 포함되는 데이터 읽기 및 설정 : byte[] 타입으로 패킷에 포함된 데이터를 읽기 및 쓰기, 이때 getData()의 리턴값은 offset, length와 관계 없이 buf값 리턴 (패킷당 전송가능한 최대 raw 데이터 = 65508 bytes)
int / getLength() / 데이터 길이 읽기 및 설정 및 오프셋 읽기 : 패킷에 포함되는 데이터의 길이 읽기 및 쓰기와 오프셋 읽기
int / getOffset() / 데이터 길이 읽기 및 설정 및 오프셋 읽기 : 패킷에 포함되는 데이터의 길이 읽기 및 쓰기와 오프셋 읽기
void / setLength(int length) / 데이터 길이 읽기 및 설정 및 오프셋 읽기 : 패킷에 포함되는 데이터의 길이 읽기 및 쓰기와 오프셋 읽기

import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;

public class DatagramPacketObject {
public static void main(String[] args) {

// 1. 데이터 생성 (byte[] : 65536 bytes(64 Kbytes) - 20 byte(IP 헤더) - 8 byte(UDP 헤더)
// = 65508 byte
byte[] buf = "UDP-데이터그램패킷".getBytes();

// 2. DatagramPacket 객체 생성
// 2-1. 수신지 주소 미포함 패킷
DatagramPacket dp1 = new DatagramPacket(buf, buf.length);
DatagramPacket dp2 = new DatagramPacket(buf, 4, buf.length - 4);

// 2-1. 수신지 정보(IP, Port) 포함 패킷
DatagramPacket dp3 = null;
DatagramPacket dp4 = null;
try {
dp3 = new DatagramPacket(buf, buf.length, InetAddress.getByName("localhost"), 10000);
dp4 = new DatagramPacket(buf, 4, buf.length - 4, InetAddress.getByName("localhost"), 10000);
} catch (UnknownHostException e) {
e.printStackTrace();
}

// 2-3. 수신지 정보(IP, Port) 포함 패킷
DatagramPacket dp5 = new DatagramPacket(buf, buf.length, new InetSocketAddress("localhost", 10000));
DatagramPacket dp6 = new DatagramPacket(buf, 4, buf.length - 4, new InetSocketAddress("localhost", 10000));

// 3. DatagramPacket method
System.out.println("원격지 IP : " + dp1.getAddress()); // null
System.out.println("원격지 Port : " + dp1.getPort());
// System.out.println("원격지 IP : " + dp1.getSocketAddress()); // IllegalArgumentException

System.out.println("원격지 IP : " + dp3.getAddress()); // localhost/127.0.0.1
System.out.println("원격지 Port : " + dp3.getPort()); // 10000
System.out.println("원격지 IP : " + dp3.getSocketAddress()); // localhost/127.0.0.1:10000
System.out.println();

System.out.println("포함 데이터 : " + new String(dp1.getData())); // UDP-데이터그램패킷
System.out.println("포함 데이터 : " + new String(dp2.getData())); // UDP-데이터그램패킷
System.out.println("포함 데이터 : " + new String(dp2.getData(), dp2.getOffset(), dp2.getLength())); // 데이터그램패킷

dp1.setData("안녕하세요".getBytes());
System.out.println("포함 데이터 : " + new String(dp1.getData())); // 안녕하세요
}
}

[DatagramSocket]
UDP 통신에서 DatagramPacket을 네트워크를 통해 전송하거나 수신하는 소켓(우편함 개념) 클래스

DatagramSocket 객체 생성 (소켓에 도착한 DatagramPacket을 바인딩 된 포트로 전달하는 기능) :
생성자 / 동작 // SocketException 처리 필요
DatagramSocket() / 기본 생성자로 객체를 생성하는 경우 객체 생성 호스트에 가용한 Port에 바인딩 된 DatagramSocket() 객체 생성
DatagramSocket(int port) / 입력 매개 변수로 전달된 포트로 바인딩된 DatagramSocket() 객체 생성 (DatagramSocket에 DatagramPacket이 도착하면 바인딩된 Port로 전달)
DatagramSocket(int port, InetAddress Iaddr) / 매개 변수로 전달된 InetAddress의 port에 바인딩 된 DatagramSocket 객체 생성
DatagramSocket(SocketAddress bindaddr) / 매개 변수로 전달된 SocketAddress에 바인딩 된 DatagramSocket 객체 생성

DatagramSocket 주요 메서드 :
리턴 타입 / 메서드명 / 동작
void / send(DatagramPacket p) / DatagramPacket의 전송과 수신 : (IOException) 데이터를 포함한 DatagramPacket을 전송하고 수신된 DatagramPacket을 비어 있는 DatagramPacket으로 담아서 수신
void / receive(DatagramPacket p) / DatagramPacket의 전송과 수신 : (IOException) 데이터를 포함한 DatagramPacket을 전송하고 수신된 DatagramPacket을 비어 있는 DatagramPacket으로 담아서 수신
void / connect(InetAddress address, int port) / 원격지 DatagramSocket 주소로 연결 및 연결 해제 : 매개 변수로 입력된 주소로 실제 연결 수행 및 연결 해제
void / connect(SocketAddress addr) / 원격지 DatagramSocket 주소로 연결 및 연결 해제 : 매개 변수로 입력된 주소로 실제 연결 수행 및 연결 해제
void / disconnect() / 원격지 DatagramSocket 주소로 연결 및 연결 해제 : 매개 변수로 입력된 주소로 실제 연결 수행 및 연결 해제
InetAddress / getInetAddress() / 원격지 주소 정보 : 원격지의 InetAddress와 Port값 읽기 (단, connect()를 통해 연결이 된 경우 유효한 값 리턴)
int / getPort() / 원격지 주소 정보 : 원격지의 InetAddress와 Port값 읽기 (단, connect()를 통해 연결이 된 경우 유효한 값 리턴)
InetAddress / getLocalAddress() / 로컬 주소 정보 : 바인딩 된 로컬 호스트의 InetAddress, Port 또는 이 둘의 정보를 포함한 SocketAddress의 정보를 리턴
int / getLocalPort() / 로컬 주소 정보 : 바인딩 된 로컬 호스트의 InetAddress, Port 또는 이 둘의 정보를 포함한 SocketAddress의 정보를 리턴
SocketAddress / getLocalSocketAddress / 로컬 주소 정보 : 바인딩 된 로컬 호스트의 InetAddress, Port 또는 이 둘의 정보를 포함한 SocketAddress의 정보를 리턴
int / int getReceiveBufferSize() / 송수신 버퍼 크기의 읽기 및 설정 : 송수신시 사용되는 버퍼 크기의 읽기 및 설정 (SocketException) (미설정시 송수신 버퍼크기는 65,536 byte)
int / int getSendBufferSize() / 송수신 버퍼크기의 읽기 및 설정 : 송수신시 사용되는 버퍼 크기의 읽기 및 설정 (SocketException) (미설정시 송수신 버퍼크기는 65,536 byte)
void / void setReceiveBufferSize(int size) / 송수신 버퍼 크기의 읽기 및 설정 : 송수신시 사용되는 버퍼 크기의 읽기 및 설정 (SocketException) (미설정시 송수신 버퍼 크기는 65,536 byte)
void / void setSendBufferSize(int size) / 송수신 버퍼크기의 읽기 및 설정 : 송수신시 사용되는 버퍼 크기의 읽기 및 설정 (SocketException) (미설정시 송수신 버퍼 크기는 65,536 byte)
int / getSoTimeout() / 수신 리스닝 시간 : DatagramPacket의 수신을 기다리는 시간 읽기 및 설정 (timeout = 0이면 무한 대기) (시간 완료시 SocketTimeoutException 발생)
void / setSoTimeout(int timeout) / 수신 리스닝 시간 : DatagramPacket의 수신을 기다리는 시간 읽기 및 설정 (timeout = 0이면 무한 대기) (시간 완료시 SocketTimeoutException 발생)

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketException;
import java.net.UnknownHostException;

public class DatagramSocketObject {
public static void main(String[] args) {

// 1. DatagramSocket 객체 생성 (모든 DatagramSocket은 바인딩 되어 있어야 함)
DatagramSocket ds1 = null;
DatagramSocket ds2 = null;
DatagramSocket ds3 = null;
DatagramSocket ds4 = null;

try {
ds1 = new DatagramSocket(); // 비어있는 포트로 자동 바인딩
ds2 = new DatagramSocket(10000);
ds3 = new DatagramSocket(10001, InetAddress.getByName("localhost"));
ds4 = new DatagramSocket(new InetSocketAddress("localhost", 10002));
} catch (SocketException | UnknownHostException e) {
e.printStackTrace();
}

// 2. DatagramSocket 메서드
// 2-1. 소켓의 바인딩 정보
System.out.println("ds1의 바인딩 정보 : " + ds1.getLocalAddress() + ":" + ds1.getLocalPort());
System.out.println("ds2의 바인딩 정보 : " + ds2.getLocalAddress() + ":" + ds2.getLocalPort());
System.out.println("ds3의 바인딩 정보 : " + ds3.getLocalAddress() + ":" + ds3.getLocalPort());
System.out.println("ds4의 바인딩 정보 : " + ds4.getLocalAddress() + ":" + ds4.getLocalPort());

// 2-2. 원격지 정보 저장 (connect() 메서드 사용)
System.out.println("원격지 주소 정보 : " + ds4.getInetAddress() + ":" + ds4.getPort());
try {
ds4.connect(new InetSocketAddress("localhost", 10003));
} catch (SocketException e) {
e.printStackTrace();
}
System.out.println("원격지 주소 정보 : " + ds4.getInetAddress() + ":" + ds4.getPort());
ds4.disconnect();
System.out.println();

// 2-3. send()/connect(), receive()
// 전송 데이터그램 패킷 2개 생성
byte[] data1 = "수신지 주소가 없는 데이터그램 패킷".getBytes();
byte[] data2 = "수신지 주소가 있는 데이터그램 패킷".getBytes();
DatagramPacket dp1 = new DatagramPacket(data1, data1.length);
DatagramPacket dp2 = new DatagramPacket(data2, data2.length, new InetSocketAddress("localhost", 10002));

try {
// ds1.send(dp1); // 불가능 : 소켓은 연결(connect)된 정보 없음 + 패킷은 수신지 정보 없음
// ds2.send(dp1); // 불가능 : 소켓은 연결(connect)된 정보 없음 + 패킷은 수신지 정보 없음
// ds3.send(dp1); // 불가능 : 소켓은 연결(connect)된 정보 없음 + 패킷은 수신지 정보 없음

ds1.connect(new InetSocketAddress("localhost", 10002));
ds2.connect(new InetSocketAddress("localhost", 10002));
ds3.connect(new InetSocketAddress("localhost", 10002));

ds1.send(dp1); // 가능 : 소켓은 연결(connect)된 정보 있음 + 패킷은 수신지 정보 없음
ds2.send(dp1); // 가능 : 소켓은 연결(connect)된 정보 있음 + 패킷은 수신지 정보 없음
ds3.send(dp1); // 가능 : 소켓은 연결(connect)된 정보 있음 + 패킷은 수신지 정보 없음

ds1.disconnect();
ds2.disconnect();
ds3.disconnect();

ds1.send(dp2); // 가능 : 소켓은 연결(connect)된 정보 없음 + 패킷은 수신지 정보 있음
ds2.send(dp2); // 가능 : 소켓은 연결(connect)된 정보 없음 + 패킷은 수신지 정보 있음
ds3.send(dp2); // 가능 : 소켓은 연결(connect)된 정보 없음 + 패킷은 수신지 정보 있음

ds3.connect(new InetSocketAddress("localhost", 10002));
ds3.send(dp2); // 가능 : 소켓은 연결(connect)된 정보 있음 + 패킷은 수신지 정보 있음 : 두 주소 일치
ds3.disconnect();

// 패킷의 주소와 소켓의 연결 주소가 불일치하는 경우
// ds3.connect(new InetSocketAddress("localhost", 10003));
// ds3.send(dp2); // 가능 : 소켓은 연결(connect)된 정보 있음 + 패킷은 수신지 정보 있음 : 두 주소 일치 // IllegalArgumentException
// ds3.disconnect();

// 데이터 수신
byte[] receivedData = new byte[65508];
DatagramPacket dp = new DatagramPacket(receivedData, receivedData.length);

for (int i = 0; i < 7; i++) {
ds4.receive(dp);
System.out.print("송신자 정보 : " + dp.getAddress() + ":" + dp.getPort());
System.out.println(" : " + new String(dp.getData()).trim());
}

// 송수신 데이터 버퍼
System.out.println("송신 버퍼 크기 : " + ds1.getSendBufferSize());
System.out.println("수신 버퍼 크기 : " + ds1.getReceiveBufferSize());
} catch (IOException e) {
e.printStackTrace();
}
}
}

UDP 통신 Client간 Text 전송 예제 (nonconnected) (ClientA) :
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

public class NonConnectedUDP_Text_ClientA {
public static void main(String[] args) {

System.out.println("<<Client A>> - Text");

// 1. DatagramSocket 객체 생성 (binding)
DatagramSocket ds = null;
try {
ds = new DatagramSocket(10000);
} catch (SocketException e) {
e.printStackTrace();
}

// 2. 전송 데이터 생성 + DatagramPacket 생성
byte[] sendData = "안녕하세요".getBytes();
DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length,
new InetSocketAddress("localhost", 20000));

// 3. 데이타그램 패킷 전송
System.out.println(
"송신 데이터 : " + new String(sendPacket.getData(), sendPacket.getOffset(), sendPacket.getLength()));
try {
ds.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 4. 데이터그램 패킷 수신
byte[] receivedData = new byte[65508];
DatagramPacket receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
ds.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}
System.out.println("수신 데이터 : "
+ new String(receivedPacket.getData(), receivedPacket.getOffset(), receivedPacket.getLength()));
}
}

UDP 통신 Client간 Text 전송 예제 (nonconnected) (ClientB) :
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

public class NonConnectedUDP_Text_ClientB {
public static void main(String[] args) {

System.out.println("<<Client B>> - Text");

// 1. DatagramSocket 객체 생성 (binding)
DatagramSocket ds = null;
try {
ds = new DatagramSocket(20000);
} catch (SocketException e) {
e.printStackTrace();
}

// 2. 데이터그램 패킷 수신
byte[] receivedData = new byte[65508];
DatagramPacket receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
ds.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}
System.out.println("수신 데이터 : "
+ new String(receivedPacket.getData(), receivedPacket.getOffset(), receivedPacket.getLength()));

// 3. 전송 데이터 생성 + DatagramPacket 생성
byte[] sendData = "반갑습니다.".getBytes();
DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, receivedPacket.getSocketAddress());

// 4. 데이타그램 패킷 전송
System.out.println(
"송신 데이터 : " + new String(sendPacket.getData(), sendPacket.getOffset(), sendPacket.getLength()));
try {
ds.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}
}
}

UDP 통신 Client간 File 전송 예제 (connected) (ClientA) :
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

public class ConnectedUDP_File_ClientA {
public static void main(String[] args) {

System.out.println("<<Client A>> - File");

// 1. DatagramSocket 생성 (binding 포함)
DatagramSocket ds = null;
try {
ds = new DatagramSocket(10000);
ds.connect(new InetSocketAddress("localhost", 20000));
} catch (SocketException e) {
e.printStackTrace();
}

// 2. 파일 로딩
File file = new File("src\\sec03_udpcommunication\\files_clientA\\javatest_cat.jpg");
BufferedInputStream bis = null;
try {
bis = new BufferedInputStream(new FileInputStream(file));
} catch (FileNotFoundException e) {
e.printStackTrace();
}

// 3. 데이터그램 패킷 전송
DatagramPacket sendPacket = null;

// 3-1. 파일 이름 전송
String fileName = file.getName();
sendPacket = new DatagramPacket(fileName.getBytes(), fileName.getBytes().length); // 수신지 정보 없음
try {
ds.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 3-2. 파일 전송 시작을 알리는 사인 전송 (/start)
String startSigh = "/start";
sendPacket = new DatagramPacket(startSigh.getBytes(), startSigh.getBytes().length); // 수신지 정보 없음
try {
ds.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 3-3. 2048 사이즈로 나누어 실제 파일 데이터 전송
int len;
byte[] filedata = new byte[2048]; // 최대 65508 byte이지만 2048로 나누어 전송
try {
while ((len = bis.read(filedata)) != -1) {
sendPacket = new DatagramPacket(filedata, len);
ds.send(sendPacket);
}
} catch (IOException e1) {
e1.printStackTrace();
}

// 3-4. 파일 전송 끝을 알리는 사인 전송 (/end)
String endSigh = "/end";
sendPacket = new DatagramPacket(endSigh.getBytes(), endSigh.getBytes().length); // 수신지 정보 없음
try {
ds.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 4. 데이터그램 텍스트 패킷 수신
byte[] receivedData = new byte[65508];
DatagramPacket receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
ds.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}
System.out.println("수신데이터 : " + new String(receivedPacket.getData()).trim());
}
}

UDP 통신 Client간 File 전송 예제 (connected) (ClientB) :
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.SocketException;

public class ConnectedUDP_File_ClientB {
public static void main(String[] args) {

System.out.println("<<Client B>> - File");

// 1. DatagramSocket 생성 (binding 포함)
DatagramSocket ds = null;
try {
ds = new DatagramSocket(20000);
ds.connect(new InetSocketAddress("localhost", 10000));
} catch (SocketException e) {
e.printStackTrace();
}

// 2. 데이터그램 패킷 수신
byte[] receivedData = null;
DatagramPacket receivedPacket = null;

// 2-1. 파일 이름 수신
receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
ds.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}
String fileName = new String(receivedPacket.getData(), 0, receivedPacket.getLength());
File file = new File("src\\sec03_udpcommunication\\files_clientB\\" + fileName);

BufferedOutputStream bos = null;
try {
bos = new BufferedOutputStream(new FileOutputStream(file));
} catch (FileNotFoundException e) {
e.printStackTrace();
}
System.out.println("수신 파일 이름 : " + fileName);

// 2-2 시작 태그와 끝 태그를 기준으로 파일 수신
String startSigh = "/start";
String endSigh = "/end";

receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);

try {
ds.receive(receivedPacket);
if (new String(receivedPacket.getData(), 0, receivedPacket.getLength()).equals(startSigh)) {
while (true) {
ds.receive(receivedPacket);
if (new String(receivedPacket.getData(), 0, receivedPacket.getLength()).equals(endSigh))
break;
bos.write(receivedPacket.getData(), 0, receivedPacket.getLength());
bos.flush();
}
}
bos.close();
} catch (IOException e) {
e.printStackTrace();
}

// 3. 파일 전송 완료 메세지 응답
byte[] sendData = "파일 수신 완료".getBytes();
DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length); // 수신지 정보 없음
try {
ds.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}
}
}

[Multicast 통신]
Multicast 통신 매커니즘 → 그룹 Join을 통한 데이터그램 패킷 전송 및 수신

Client
(Data)
↓
DatagramPacket
(Data)
↓ ① Port : XXXX
MulticastSocket
DatagramPacket
(Data)
② ↓ joinGroup(.)
③ ↓
Multicast Group (클래스 D)
④ ↓
② ↑ joinGroup(.)
↑ ① Port : XXXX
MulticastSocket
DatagramPacket
(Data)
↑
DatagramPacket
(Data)
↑
Client
(Data)

번호 / 동작
1 / 각 클라이언트는 Multicast를 지원하는 MulticastSocket 생성 (바인딩 정보 필수 포함 (바인딩 port 미지정시 비어있는 port 자동 바인딩))
2 / 생성 MulticastSocket을 멀티캐스팅 IP(클래스 D)를 가지는 Multicast Group에 조인 (joinGroup(InetAddress))
3 / (송신) 보낼 데이터를 DatagramPacket에 담아 MulticastSocket을 통해 보내기 (send(.))
4 / (수신) Multicast Group에 패킷이 전달되면 패킷의 수신 포트로 바인딩 된 조인된 모든 Client에게 패킷 전송 (receive(.))
// 클래스 D : 224.0.0.0 ~ 239.255.255.255

송신 매커니즘 (그룹 Join을 통한 UDP 패킷 전송 및 수신)
Client A
IP : 192.168.23.159
(Data)
↓
DatagramPacket
(Data)
IP : 234.234.234.234
Port : 10000
↓
MulticastSocket - 10000
DatagramPacket
(Data)
IP : 234.234.234.234
Port : 10000
↓ joinGroup(.) ↓ send(.)
Multicast Group
IP : 234.234.234.234
// send(.) : Multicast Group(joinGroup())이 안되어 있어도 전송 가능
// joinGroup(.) → send(.) : Multicast Group에 등록되어 있는 경우 DatagramPacket의 수신지 port = MulticastSocket 바인딩 port 이면 자신이 보낸 데이터를 자신도 받음

수신 매커니즘 (그룹 Join을 통한 UDP 패킷 전송 및 수신)
DatagramPacket
(Data)
IP : 234.234.234.234
Port : 10000
↓ send(.)
Multicast Group
IP : 234.234.234.234

↓↑ joinGroup(.)
MulticastSocket - bind() 10000
DatagramPacket
↓
DatagramPacket
(Data)
↓
Client B
(Data)

↓↑ joinGroup(.)
MulticastSocket - bind() 10000
DatagramPacket
↓
DatagramPacket
(Data)
↓
Client C
(Data)

↑ joinGroup(.)
MulticastSocket - bind() 20000

Client D
// MulticastSocket은 하나의 포트에 여러 개의 MulticastSocket 바인딩 가능
// 외부 IP에서 보내는 데이터 수신을 위해서는 localhost가 아닌 실제 IP 입력

[MulticastSocket]
가상의 멀티캐스트 그룹에 가입(join)할 수 있는 소켓으로 멀티캐스트를 지원

MulticastSocket 객체 생성 :
생성자 / 동작
MulticastSocket() / 포트를 지정하지 않는 경우 비워져 있는 포트로 자동 바인딩 (주로 송신하는 경우에 사용)
MulticastSocket(int port) / 매개 변수로 전달된 port로 가상의 Multicast Group에서 수신할 포트를 바인딩 (즉, Multicast Group에 도착하는 패킷 중 포트가 port인 데이터를 수신)
MulticastSocket(SocketAddress bindaddr) / 매개 변수로 전달된 SocketAddress로 바인딩 (이때 데이터 수신을 위해서는 127.0.0.1 또는 localhost가 아닌 실제 IP를 정보를 포함하는 InetAddress을 지정)

MulticastSocket의 주요 메서드 :
리턴 타입 / 메서드명 / 동작
int / getTimeToLive() / 패킷의 생존 기간 읽기 및 설정 : 0~255까지 가능 (이외 IllegalArgumentException 발생) : 단말(스위치, 라우터 등)을 통과할 때 마다 숫자 감소 (1(default)인 경우 내부 네트워크에서만 사용)
void / setTimeToLive(int ttl) / 패킷의 생존 기간 읽기 및 설정 : 0~255까지 가능 (이외 IllegalArgumentException 발생) : 단말(스위치, 라우터 등)을 통과할 때 마다 숫자 감소 (1(default)인 경우 내부 네트워크에서만 사용)
void / joinGroup(InetAddress mcastaddr) / Multicast Group에 가입 및 해제 : 그룹에 가입한 경우 이후의 바인딩 된 포트로 들어오는 모든 패킷 수신 가능 (해제(leaveGroup())시 수신 불가)
void / leaveGroup(InetAddress mcastaddr) / Multicast Group에 가입 및 해제 : 그룹에 가입한 경우 이후의 바인딩 된 포트로 들어오는 모든 패킷 수신 가능 (해제(leaveGroup())시 수신 불가)
void / send(DatagramPacket p) / 데이터그램 패킷의 전송과 수신 : 상위 클래스인 DatagramSocket의 메서드로 데이터그램의 패킷 전송과 수신 수행
void / receive(DatagramPacket p) / 데이터그램 패킷의 전송과 수신 : 상위 클래스인 DatagramSocket의 메서드로 데이터그램의 패킷 전송과 수신 수행

// 브로드캐스팅 : 멀티캐스팅 주소가 아니라 브로드캐스팅 주소(255.255.255.255)로 데이터그램 패킷을 전송하는 경우 내부 네트워크의 모든 단말에 전달(join 등의 과정 없음)

Multicast 통신 Client간 Text 전송 예제 (ClientA) :
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.net.UnknownHostException;

public class Multicast_Text_ClientA {
public static void main(String[] args) {

System.out.println("<<Client A>> - Text");

// 1. 멀티캐스팅 주소지 생성
InetAddress multicastAddress = null;
try {
multicastAddress = InetAddress.getByName("234.234.234.234");
} catch (UnknownHostException e) {
e.printStackTrace();
}
int multicastPort = 10000;

// 2. 멀티캐스트 소켓 생성
MulticastSocket mcs = null;
try {
mcs = new MulticastSocket(multicastPort);
} catch (IOException e) {
e.printStackTrace();
}

// 3. 멀티캐스트 그룹에 조인
try {
mcs.joinGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 4. 전송 데이터그램 패킷 생성 + 전송
byte[] sendData = "안녕하세요!(Client A)".getBytes();

DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, multicastAddress, multicastPort);
try {
mcs.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 5. 데이터그램 패킷 수신
receiveMessage(mcs); // 자기가 보낸 데이터 수신
receiveMessage(mcs); // 상대편이 보낸 데이터 수신

// 6. 멀티캐스트 그룹 나가기
try {
mcs.leaveGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 7. 소켓 닫기
mcs.close();
}

static void receiveMessage(MulticastSocket mcs) {
byte[] receivedData;
DatagramPacket receivedPacket;

receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
mcs.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}

System.out.println("보내온 주소 : " + receivedPacket.getSocketAddress());
System.out.println("보내온 내용 : " + new String(receivedPacket.getData()).trim());
}
}

Multicast 통신 Client간 Text 전송 예제 (ClientB) :
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.net.UnknownHostException;

public class Multicast_Text_ClientB {
public static void main(String[] args) {

System.out.println("<<Client B>> - Text");

// 1. 멀티캐스팅 주소지 생성
InetAddress multicastAddress = null;
try {
multicastAddress = InetAddress.getByName("234.234.234.234");
} catch (UnknownHostException e) {
e.printStackTrace();
}
int multicastPort = 10000;

// 2. 멀티캐스트 소켓 생성
MulticastSocket mcs = null;
try {
mcs = new MulticastSocket(multicastPort);
} catch (IOException e) {
e.printStackTrace();
}

// 3. 멀티캐스트 그룹에 조인
try {
mcs.joinGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 4. 데이터그램 패킷 수신 대기
receiveMessage(mcs); // ClientA가 보낸 메시지 수신

// 5. 전송 데이터그램 패킷 생성 + 전송
byte[] sendData = "반갑습니다!(Client B)".getBytes();

DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, multicastAddress, multicastPort);
try {
mcs.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// #. 데이터그램 패킷 수신 대기
receiveMessage(mcs); // ClientB(자기)가 보낸 메시지 수신

// 7. 멀티캐스트 그룹 나가기
try {
mcs.leaveGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 8. 소켓 닫기
mcs.close();
}

static void receiveMessage(MulticastSocket mcs) {
byte[] receivedData;
DatagramPacket receivedPacket;

receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
mcs.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}

System.out.println("보내온 주소 : " + receivedPacket.getSocketAddress());
System.out.println("보내온 내용 : " + new String(receivedPacket.getData()).trim());
}
}

Multicast 통신 Client간 File 전송 예제 (ClientA) :
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.net.UnknownHostException;

public class Multicast_File_ClientA {
public static void main(String[] args) {

System.out.println("<<Client A>> - File");

// 1. 멀티캐스팅 주소지 생성
InetAddress multicastAddress = null;
try {
multicastAddress = InetAddress.getByName("234.234.234.234");
} catch (UnknownHostException e) {
e.printStackTrace();
}
int multicastPort = 10000;

// 2. 멀티캐스트 소켓 생성
MulticastSocket mcs = null;
try {
mcs = new MulticastSocket(multicastPort);
} catch (IOException e) {
e.printStackTrace();
}

// 3. 파일 로딩
File file = new File("src\\sec04_multicastcommunication\\files_clientA\\multicast_cat.jpg");
BufferedInputStream bis = null;
try {
bis = new BufferedInputStream(new FileInputStream(file));
} catch (FileNotFoundException e) {
e.printStackTrace();
}

// 4. 파일 데이터 전송
DatagramPacket sendPacket = null;

// 4-1. 파일 이름 전송
String fileName = file.getName();
sendPacket = new DatagramPacket(fileName.getBytes(), fileName.length(), multicastAddress, multicastPort);
try {
mcs.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}
System.out.println(fileName + " 파일 전송 시작");

// 4-1. 파일 시작 태그를 전송 (/start)
String startSigh = "/start";
sendPacket = new DatagramPacket(startSigh.getBytes(), startSigh.length(), multicastAddress, multicastPort);
try {
mcs.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 4-2. 실제 파일 데이터 전송 (2048 사이즈로 나누어서 파일 전송)
int len;
byte[] filedata = new byte[2048];
try {
while ((len = bis.read(filedata)) != -1) {
sendPacket = new DatagramPacket(filedata, len, multicastAddress, multicastPort);
mcs.send(sendPacket);
}
} catch (IOException e1) {
e1.printStackTrace();
}

// 4-3. 파일 끝 태그를 전송 (/end)
String endSigh = "/end";
sendPacket = new DatagramPacket(endSigh.getBytes(), endSigh.length(), multicastAddress, multicastPort);
try {
mcs.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 5. 멀티캐스트 그룹에 조인
try {
mcs.joinGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 6. 데이터 수신 대기
receiveMessage(mcs);

// 7. 멀티캐스트 그룹 나가기
try {
mcs.leaveGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 8. 소켓 닫기
mcs.close();

}

static void receiveMessage(MulticastSocket mcs) {
byte[] receivedData;
DatagramPacket receivedPacket;

receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
mcs.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}

System.out.println("보내온 주소 : " + receivedPacket.getSocketAddress());
System.out.println("보내온 내용 : " + new String(receivedPacket.getData()).trim());
}
}

Multicast 통신 Client간 File 전송 예제 (ClientB) :
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.net.UnknownHostException;

public class Multicast_File_ClientB {
public static void main(String[] args) {

System.out.println("<<Client B>> - File");

// 1. 멀티캐스팅 주소지 생성
InetAddress multicastAddress = null;
try {
multicastAddress = InetAddress.getByName("234.234.234.234");
} catch (UnknownHostException e) {
e.printStackTrace();
}
int multicastPort = 10000;

// 2. 멀티캐스트 소켓 생성
MulticastSocket mcs = null;
try {
mcs = new MulticastSocket(multicastPort);
} catch (IOException e) {
e.printStackTrace();
}

// 3. 멀티캐스트 그룹에 조인
try {
mcs.joinGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 4. 파일 데이터 수신
byte[] receivedData;
DatagramPacket receivedPacket;

// 4-1. 파일 이름 수신
receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);
try {
mcs.receive(receivedPacket);
} catch (IOException e) {
e.printStackTrace();
}
String fileName = new String(receivedPacket.getData()).trim();
System.out.println(fileName + " 파일 수신 시작");

// 4-2. 파일 저장을 위한 파일 출력 스트림 생성
File file = new File("src\\sec04_multicastcommunication\\files_clientB\\" + fileName);
BufferedOutputStream bos = null;
try {
bos = new BufferedOutputStream(new FileOutputStream(file));
} catch (FileNotFoundException e) {
e.printStackTrace();
}

// 4-3. 시작 태그부터 끝 태그까지 모든 데이터 패킷의 내용을 파일에 기록
String startSigh = "/start";
String endSigh = "/end";
receivedData = new byte[65508];
receivedPacket = new DatagramPacket(receivedData, receivedData.length);

try {
mcs.receive(receivedPacket);
if (new String(receivedPacket.getData(), 0, receivedPacket.getLength()).equals(startSigh)) {
while (true) {
mcs.receive(receivedPacket);
if (new String(receivedPacket.getData(), 0, receivedPacket.getLength()).equals(endSigh))
break;
bos.write(receivedPacket.getData(), 0, receivedPacket.getLength());
bos.flush();
}
}

} catch (IOException e) {
e.printStackTrace();
}

try {
bos.close();
} catch (IOException e) {
e.printStackTrace();
}
System.out.println("파일 수신 완료");

// 5. 멀티캐스트 그룹 나가기
try {
mcs.leaveGroup(multicastAddress);
} catch (IOException e) {
e.printStackTrace();
}

// 6. 전송 데이터그램 생성 + 전송
byte[] sendData = "(Client B) 파일 수신 완료".getBytes();
DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, multicastAddress, multicastPort);
try {
mcs.send(sendPacket);
} catch (IOException e) {
e.printStackTrace();
}

// 7. 소켓 닫기
mcs.close();
}
}