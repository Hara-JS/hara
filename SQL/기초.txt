DB(Database) : 데이터의 집합. 데이터의 저장소

Database Object(데이터베이스 개체) : 테이블, 뷰, 인덱스, 스토어드 프로시저 등 데이터베이스 안에 저장되는 개체

DBMS(Database Management System) : 데이터베이스 관리 시스템. 대량의 데이터베이스를 효율적으로 관리하고 운영하기 위한 시스템 또는 소프트웨어. 대표적으로 MySQL, 오라클(Oracle), SQL 서버(Server), MariaDB 등이 있다.
	// Microsoft 사의 Excel과 같은 프로그램은 '데이터의 집합'을 관리하고 운영한다는 차원에서는 DBMS로 볼 수 있지만, 대용량 데이터를 관리하거나 여러 사용자와 공유하는 개념과는 거리가 있어 DBMS라고 부르지 않는다.

RDBMS(Relational Database Management System) : 관계형 데이터베이스 관리 시스템. 테이블이라는 최소 단위로 이루어진 관계형 DBMS

DBMS의 분류 : 계층형(Hierarchical), 망형(Network), 관계형(Relational), 객체지향형(Object-Oriented), 객체관계형(Object-Relational)
	계층형(Hierarchical) : 처음으로 등장한 DBMS 개념. 1960년대에 시작. 각 계층은 tree(트리) 형태
	망형(Network) : 계층형 DBMS의 문제점을 개선하기 위해 1970년대에 등장. 하지만 망형 DBMS를 잘 활용하려면 프로그래머가 모든 구조를 이해해야만 프로그램 작성이 가능하다는 단점이 존재. 지금은 거의 사용하지 않는 형태
	관계형(Relational) : 대부분의 DBMS가 RDBMS 형태로 사용. RDBMS는 table(테이블)이라는 최소 단위로 구성되며, 이 테이블은 하나 이상의 column(열)과 row(행)로 이루어져 있음

SQL(Structured Query Language) : 구조화 질의어. 관계형 데이터베이스에서 사용되는 언어로 '에스큐엘' 또는 '시퀄'로 읽는다. RDBMS에서 데이터를 구축, 관리하고 활용하기 위해 사용되는 언어. 대부분의 DBMS 회사에서는 국제표준화기구에서 지정한 '표준 SQL'을 준수한다.

Standard SQL : 표준 SQL. 국제표준화기구에서 SQL에 대한 표준을 정해서 발표

MySQL : 오라클 사에서 제공하는 데이터베이스 관리 소프트웨어. 대용량의 데이터를 관리하고 운영하는 기능을 제공한다.

root : MySQL의 모든 권한이 있는 관리자 이름. MySQL을 설치할 때 기본적으로 생성된다.

MySQL Workbench : MySQL 서버에 접속해 SQL 문을 입력/실행할 수 있도록 돕는 클라이언트 도구

MySQL 로고와 MariaDB 로고 : MySQL 로고는 돌고래 이미지를 사용. MySQL이 오라클 사에 인수된 후에 오라클 정책이 마음에 들지 않은 MySQL 초기 개발자들이 독립해서 만든 것이 MariaDB. 그래서 MariaDB 로고도 돌고래와 비슷한 물개로 선정한 것으로 추정. 참고로, MySQL과 MariaDB의 이름은 초기 개발자 몬티 와이드니어스(Monty Widenius)의 딸 이름 My와 Maria에서 따왔다고 한다. MySQL과 MariaDB는 핵심 개발자가 같고, 문법도 비슷하다.

project(프로젝트) : 현실 세계의 업무를 컴퓨터 시스템으로 옮겨 놓는 일련의 과정

소프트웨어 개발 단계(폭포수 모델) : 1. 프로젝트 계획 2. 업무 분석 3. 시스템 설계 4. 프로그램 구현 5. 테스트 6. 유지보수

database modeling(데이터베이스 모델링) : 데이터베이스 구축 전 테이블의 구조를 미리 설계하는 과정. 폭포수 모델의 업무 분석과 시스템 설계 단계에 해당한다.

waterfall model(폭포수 모델) : 소프트웨어 개발 절차 중 하나로, 위에서 아래로 폭포가 떨어지듯 개발 단계가 진행되기 때문에 붙여진 이름이다.

data type(데이터 형식) : 테이블의 열에 저장될 데이터의 형식. 문자형(CHAR), 정수형(INT), 날짜형(DATE) 등이 있다.

column(열), field(필드) : 테이블의 세로. 테이블은 여러 개의 열로 구성되며, 각 열을 구분하기 위해 열 이름을 사용한다. 열 이름을 영문으로 만들 때 띄어쓰기를 할 경우에는 열 이름을 큰따옴표("")로 묶어줘야 한다. 그래서 보통은 언더바(_)로 구분한다.

row(행), record(레코드) : 테이블의 가로. 실질적인 데이터(행 데이터)를 의미한다.

데이터베이스 구축 절차 : 데이터베이스 만들기 -> 테이블 만들기 -> 데이터 입력/수정/삭제하기 -> 데이터 조회/활용하기

schema(스키마) : MySQL 안에 들어 있는 데이터베이스

reserved word(예약어) : 기존에 약속된 SQL. SELECT, FROM, WHERE 등이 있다. 쿼리 창에서 입력하면 자동으로 파란색으로 표시된다.

Null(널) : 비어 있는 값

NN(Not Null) : 빈 값을 허용하지 않는, 즉 반드시 입력해야 하는 값

remark(주석) : 하이픈(-) 2개와 설명으로 구성된다. 주의할 점은 하이픈 2개 이후에 한 칸을 띄고 설명을 작성해야 한다.

SQL의 대소문자 : SQL은 대소문자를 구분하지 않는다. 끝을 표시하기 위해서는 세미콜론(;)이 있어야 한다.

USE : 사용할 데이터베이스를 선택하는 구문으로, 한 번 지정하면 계속 유지된다. MySQL 워크벤치를 재시작하거나 쿼리 창을 새로 열면 다시 USE를 실행해야 한다. (기본 형식 : USE 데이터베이스_이름;)

SQL 예약어와 자동 완성 : 쿼리 창에서 SQL을 입력하면 예약어는 자동으로 파란색으로 표시된다. MySQL 워크벤치는 IntelliSense 또는 AutoComplete 기능을 제공한다.
	// 글자의 일부만 입력해도 그와 관련되는 글자들이 미리 제시되는 것으로 ->(오른쪽 화살표 키)와 Tab 키를 누르면 자동으로 완성
	// MySQL의 자동 완성 기능을 사용하는 법 : MySQL 워크벤치의 [Edit] - [Preferences] 메뉴에서 [SQL Editor] - [Query Editor]의 'Auto Start Code Completion' 체크

SELECT ~ FROM ~ WHERE : 가장 기본적인 SQL 문. SELECT 다음에는 열 이름이, FROM 다음에는 테이블 이름이, WHERE 다음에는 다양한 조건식이 나온다.

SELECT : 데이터를 조회하는 SQL
	SELECT 문의 기본 형식 : 
	SELECT 열_이름
		FROM 테이블_이름
		WHERE 조건식
		GROUP BY 열_이름
		HAVING 조건식
		ORDER BY 열_이름
		LIMIT 숫자

WHERE : SELECT 문에서 특정 조건을 조회할 때 사용하는 구문
	WHERE 절의 기본 형식 :
	SELECT 열_이름 FROM 테이블_이름 WHERE 조건식;
	또는
	SELECT 열_이름
		FROM 테이블_이름
		WHERE 조건식;
	// 이 형식에서 세미콜론(;)이 나오기 전까지는 한 줄로 쓰든, 여러 줄로 쓰든 동일하다. SQL이 길거나 복잡한 경우에는 여러 줄로 나눠 쓰는 것이 좀 더 읽기 편하다.
	// WHERE 없이 SELECT ~ FROM만으로 테이블을 조회하면 테이블의 모든 행이 출력된다.

* : 모든 열을 지정할 때 사용하는 기호

,(콤마) : 여러 개의 열을 가져오고 싶으면 .(콤마)로 구분하면 된다.

relational operation(관계 연산자) : WHERE 절에서 숫자로 표현된 데이터 범위의 크다/작다/같다 등을 지정하는 기호. >, <, >=, <=, = 등이 있다.

logical operation(논리 연산자) : WHERE 절에서 2가지 이상의 조건을 지정할 때 사용. AND, OR 등으로 참/거짓을 판별한다.

AND : 두 조건이 모두 만족해야 한다.

OR : 두 조건 중 하나만 만족해도 된다.

BETWEEN ~ AND : 범위에 있는 값을 구하는 경우에 사용한다.

IN() : 조건식에서 여러 문자 중 하나에 포함되는지 비교할 때 사용한다. 숫자로 구성된 데이터는 크다/작다의 범위를 지정할 수 있으므로 BETWEEN ~ AND를 사용할 수 있지만, 문자 데이터는 어느 범위에 들어 있다고 표현할 수 없다. IN()을 사용하면 코드를 훨씬 간결하게 작성할 수 있다.

LIKE : 문자열의 일부 글자를 검색할 때 사용. 모두 허용할 때는 %를, 하나로 지정할 때는 _(언더 바)를 사용한다.
	% : 문자열에서 여러 문자에 대응하는 기호
	_ : 문자열에서 한 문자에 대응하는 기호

subquery(서브 쿼리) : SELECT 안에는 또 다른 SELECT가 들어갈 수 있다. 이것을 서브 쿼리 또는 하위 쿼리라고 부른다. 서브 쿼리의 장점은 2개의 SQL을 하나로 만듦으로써 하나의 SQL만 관리하면 되므로 더 간단해진다는 것이다.

ORDER BY : 결과가 출력되는 순서를 조절한다. 오름차순인 ASC(Ascending)와 내림차순인 DESC(Descending) 중 선택할 수 있다. ASC 또는 DESC를 생략하면 기본적으로 ASC라고 인식한다. ORDER BY 절은 WHERE 절 다음에 나와야 한다.

LIMIT : 출력하는 개수를 제한하며, 주로 ORDER BY와 함께 사용한다. (LIMIT 형식 : LIMIT 개수 OFFSET 시작)

DISTICT : 조회된 결과에서 중복된 데이터를 1개만 남긴다. DISTINCT를 열 이름 앞에 붙여 사용한다.

GROUP BY : 데이터를 그룹으로 묶어주는 기능을 한다. 주로 집계 함수와 함께 사용된다.

alias(별칭) : SELECT 문에서 실제 열 이름 대신에 출력되도록 설정하는 문자. 열 이름 다음에 지정하고 싶은 별칭을 입력하면 된다. 별칭에 공백이 있으면 큰따옴표("")로 묶어준다. 별칭은 작은따옴표를 사용해도 되지만, 작은따옴표는 INSERT 등에서 문자를 입력할 때 사용하므로 별칭에는 큰 따옴표를 사용할 것을 권장한다.

aggregate function(집계 함수) : 데이터를 grouping(그룹화)해주는 기능을 한다. 주로 GROUP BY와 함께 사용한다.
	집계 함수 종류
	함수명 / 설명
	SUM() / 합계를 구한다.
	AVG() / 평균을 구한다.
	MIN() / 최소값을 구한다.
	MAX() / 최대값을 구한다.
	COUNT() / 행의 개수를 센다. COUNT(*)는 모든 행의 개수를 세고, COUNT(열_이름)은 열 이름의 값이 NULL인 것을 제외한 행의 개수를 센다.
	COUNT(DISTINCT) / 행의 개수를 센다(중복은 1개만 인정)

HAVING : 집계 함수와 관련된 조건을 제한하며, 반드시 GROUP BY 절 다음에 나와야 한다.

INSERT : 테이블에 데이터를 입력(삽입)하는 기본적인 SQL 문 (기본 형식 : INSERT INTO 테이블 [(열1, 열2, ...)] VALUES (값1, 값2, ...) 생략하면 NULL 값이 들어간다)

AUTO_INCREMENT : 열을 정의할 때 1부터 증가하는 값을 자동으로 입력해준다. 해당 열은 반드시 PRIMARY KEY로 지정해야 한다. AUTO_INCREMENT 열에 값을 입력할 때는 NULL로 지정함

시스템 변수 : MySQL에서 자체적으로 가지고 있는 설정값이 저장된 변수를 말한다. 시스템 변수는 앞에 @@가 붙는 것이 특징이며, 시스템 변수의 값을 확인하려면 SELECT @@시스템변수를 실행하면 된다. 전체 시스템 변수의 종류를 알고 싶다면 SHOW GLOBAL VARIABLES를 실행하면 된다.

INSERT INTO ~ SELECT : 다른 테이블의 데이터를 가져와 한 번에 입력한다. 단, SELECT 문의 열 개수는 INSERT를 할 테이블의 열 개수와 같아야 한다.
	INSERT INTO ~ SELECT 기본 형식 :
	INSERT INTO 테이블_이름 (열_이름1, 열_이름2, ...)
		SELECT 문;

UPDATE : 기존에 입력되어 있는 값을 수정하는 명령. 주로 WHERE 절과 함께 사용한다. WHERE 절을 생략하면 테이블의 모든 행의 값이 변경되므로 주의해야 한다.
	UPDATE 문의 기본 문법 :
	UPDATE 테이블_이름
		SET 열1=값1, 열2=값2, ...
		WHERE 조건;

데이터를 변경하려면 UPDATE ~ SET ~ WHERE 절을 사용한다. 

DROP : 데이터베이스 개체를 삭제할 때 사용하는 예약어 (DROP의 기본 형식 : DROP 개체_종류 개체_이름)

DELETE :  행 단위로 데이터를 삭제한다. WHERE 절을 생략하면 전체 행 데이터가 삭제되므로 주의해야 한다.
	DELETE 기본 형식 : DELETE FROM 테이블이름 WHERE 조건;
	테이블 삭제 :
	DELETE : 행 단위로 삭제하고 빈 테이블을 남긴다. 데이터 양이 많을 경우 시간이 오래 걸릴 수 있다.
	DROP : 테이블 자체를 삭제한다.
	TRUNCATE : WHERE 문을 사용할 수 없어 조건 없이 전체 행을 삭제하고 빈 테이블은 남긴다. TRUNCATE는 DELETE와 달리 WHERE 문을 사용할 수 없다. 그러므로 TRUNCATE는 조건 없이 전체 행을 삭제할 때만 사용된다.
	// 대용량 테이블의 전체 내용을 삭제할 때 테이블 자체가 필요 없을 경우 DROP으로 삭제하고, 테이블의 구조는 남겨놓고 싶다면 TRUNCATE로 삭제하는 것이 효율적이다. 대량의 행 데이터를 모두 삭제할 때는 DELETE보다 TRUNCATE가 효율적이다.

정수형 : 소수점이 없는 숫자이며, TINYINT, SMALLINT, INT, BIGINT 등이 있다.
	데이터 형식 / 바이트 수 / 숫자 범위
	TINYINT / 1 / -128 ~ 127
	SMALLINT / 2 / -32,768 ~ 32,767
	INT / 4 / 약 -21억 ~ + 21억
	BIGINT / 8 / 약 -900경 ~ +900경
	// 추가로 BIT, MEDIUMINT도 있으나 잘 사용하지 않는다.

UNSIGNED : 정수형에 붙이면 범위가 0부터 지정된다.

문자형 : 글자를 저장하기 위해 사용하며, 입력할 최대 글자의 개수를 지정해야 한다. 고정길이 문자형인 CHAR(Character)와 가변길이 문자형인 VARCHAR(Variable Character)가 있다.
	데이터 형식 / 바이트 수
	CHAR(개수) / 1~255
	VARCHAR(개수) / 1~16383
	// VARCHAR가 CHAR보다 공간을 효율적으로 운영할 수 있지만, MySQL 내부적으로 성능(빠른 속도)면에서는 CHAR로 설정하는 것이 좋다.

숫자로서 의미를 가지려면 다음 2가지 중 1가지는 충족해야 한다 : 1.	더하기/빼기 등의 연산에 의미가 있다. 2. 크다/작다 또는 순서에 의미가 있다. 데이터가 숫자 형태라도 연산이나 크기에 의미가 없다면 문자형으로 지정하는 것이 좋다. (예시 : 전화번호)

대량의 데이터 형식 :
	데이터 형식 / 바이트 수
	TEXT 형식 / TEXT / 1~65535
	TEXT 형식 / LONGTEXT / 1~4294967295
	BLOB 형식 / BLOB / 1~65535
	BLOB 형식 / LONGBLOB / 1~4294967295
	// 추가로 TINYTEXT, MEDIUMTEXT, TINYBLOB, MEDIUMBLOB 등도 있지만 잘 사용하지 않는다.

BLOB(Binary Long Object) : 글자가 아닌 이미지, 동영상 등의 데이터. 이진(Binary) 데이터

실수형 : 소수점이 있는 숫자를 저장할 때 사용한다. 소수점 아래 7자리까지 표현되는 FLOAT와 소수점 아래 15자리까지 표현되는 DOUBLE이 있다.
	데이터 형식 / 바이트 수 /설명
	FLOAT / 4 / 소수점 아래 7자리까지 표현
	DOUBLE / 8 / 소수점 아래 15자리까지 표현

날짜형 : 날짜를 지정하는 DATE, 시간을 저장하는 TIME, 날짜와 시간을 둘다 저장하는 DATETIME이 있다.
	데이터 형식 / 바이트 수 / 설명
	DATE / 3 / 날짜만 저장. YYYY-MM-DD 형식으로 저장
	TIME / 3 / 시간만 저장. HH:MM:SS 형식으로 사용
	DATETIME / 8 / 날짜 및 시간을 저장. YYYY-MM-DD HH:MM:SS 형식으로 사용

variable(변수) : MySQL에서는 변수 이름 앞에 @을 붙이고 SET 문으로 변수에 값을 대입한다.
	변수의 선언과 값의 대입 :
	SET @변수이름 = 변수의 값 ; // 변수의 선언 및 값 대입
	SELECT @변수이름 ; // 변수의 값 출력

type conversion(형 변환) : 문자형, 정수형 등의 데이터 형식을 다른 형태로 변경하는 것. 직접 함수를 사용해서 변환하는 명시적 변환(explicit conversion)과 별도의 지시 없이 자연스럽게 변환되는 암시적 변환(implicit conversion)이 있다. 명시적 변환에는 CAST(), CONVERT() 등을 사용한다.
	CAST ( 값 AS 데이터_형식 [ (길이) ] )
	CONVERT ( 값, 데이터_형식 [ (길이) ] )
	// CAST()나 CONVERT() 함수 안에 올 수 있는 데이터 형식은 CHAR, SIGNED(부호가 있는 정수. SIGNED INTEGER라고 써도 된다), UNSIGNED(부호가 없는 정수. UNSIGNED INTEGER라고 써도 된다), DATE, TIME, DATETIME 등이 있다.

CONCAT() : 문자를 이어주는 함수

join(조인) : 두 개의 테이블을 서로 묶어서 하나의 결과를 만들어 내는 것

one to many(일대다 관계) : 두 테이블이 조인할 경우 한쪽 테이블에는 하나의 값만 존재해야 하지만, 연결된 다른 테이블에는 여러 개의 값이 존재할 수 있는 관계를 말한다. 주로 기본 키(PK)와 외래 키(FK) 관계로 맺어져 있어 'PK-FK 관계'라고 부르기도 한다.

inner join(내부 조인) : 두 테이블을 조인할 때, 두 테이블에 모두 데이터가 있어야 결과가 추출된다. 조인 중에 가장 많이 사용되며, 일반적으로 조인이라고 하면 바로 이 내부 조인을 뜻한다.
	내부 조인의 형식 :
	SELECT <열 목록>
	FROM < 첫 번째 테이블>
		INNER JOIN <두 번째 테이블>
	ON <조인될 조건>
	[WHERE 검색 조건]
	// INNER JOIN을 그냥 JOIN이라고만 써도 INNER JOIN으로 인식한다.
	// 두 개의 테이블을 조인하는 경우 동일한 열 이름이 존재한다면 테이블_이름.열_이름 형식으로 표기해야 한다.
	// 여러 개의 테이블이 관련된 조인에서는 테이블의 이름 뒤에 alias(별칭)을 주는 방식을 적극 권장한다.

outer join(외부 조인) : 두 테이블을 조인할 때, 필요한 데이터가 한쪽 테이블에만 있어도 결과를 추출할 수 있다.
	외부 조인의 형식 :
	SELECT <열 목록>
	FROM <첫 번째 테이블(LEFT 테이블)>
		<LEFT | RIGHT | FULL> OUTER JOIN <두 번째 테이블(RIGHT 테이블)>
		ON <조인될 조건>
	[WHERE 검색 조건] ;
	// LEFT OUTER JOIN : 왼쪽 테이블의 모든 값이 출력되는 조인. LEFT OUTER JOIN을 줄여서 LEFT JOIN이라고만 써도 된다.
	// RIGHT OUTER JOIN : 오른쪽 테이블의 모든 값이 출력되는 조인
	// FULL OUTER JOIN : 왼쪽 또는 오른쪽 테이블의 모든 값이 출력되는 조인. 자주 사용하지는 않는다.

cross join(상호 조인) : 한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인시키는 기능. 따라서 상호 조인 결과의 전체 행 개수는 두 테이블의 각 행 개수를 곱한 개수가 된다. 상호 조인은 cartesian product(카티션 곱)라고도 부른다.
	상호 조인의 특징 : 1. ON 구문을 사용할 수 없다. 2. 결과의 내용은 의미가 없다. (랜덤으로 조인하기 때문) 3. 상호 조인의 주 용도는 테스트하기 위해 대용량의 데이터를 생성할 때이다.

self join(자체 조인) : 자신이 자신과 조인된다는 의미로, 하나의 테이블에 서로 다른 별칭을 붙여 사용한다.
	자체 조인의 형식 :
	SELECT <열 목록>
	FROM <테이블> 별칭A
		INNER JOIN <테이블> 별칭B
		ON <조인될 조건>
	[WHERE 검색 조건]

CREATE TABLE ~ SELECT : SELECT의 결과가 테이블로 생성되는 구문

IF 문 : 다양한 조건을 처리할 때 사용한다. 조건식이 참이라면 결과가 실행되지만, 그렇지 않으면 실행되지 않는다.
	IF 문의 형식 :
	IF <조건식> THEN
		SQL문장들
	END IF;
	// 'SQL문장들'이 한 문장이라면 그 문장만 써도 되지만, 두 문장 이상이 처리되어야 할 때는 BEGIN ~ END로 묶어줘야 한다. 습관적으로 BEGIN ~ END로 묶어주는 것을 권장한다.
	// 다른 프로그래밍 언어에서는 같다는 의미로 ==을 사용하지만, SQL은 =을 사용한다. 그리고 SELECT 뒤에 문자가 나오면 그냥 화면에 출력해준다. 다른 언어의 print()와 비슷한 기능

IF ~ ELSE 문 : 조건식이 참일 때와 거짓일 때 각각 다른 부분을 실행한다.

날짜 관련 함수 :
	CURRENT_DATE() : 오늘 날짜를 알려준다.
	CURRENT_TIMESTAMP() :오늘 날짜 및 시간을 함께 알려준다.
	DATEDIFF(날짜1, 날짜2) : 날짜2부터 날짜1까지 일수로 몇일인지 알려준다.

CASE 문 : 2가지 이상의 여러 가지 조건에 따라 처리가 가능하며, '다중 분기'라고 부른다.
	CASE 문의 형식 :
	CASE
		WHEN 조건1 THEN
			SQL문장들1
		WHEN 조건2 THEN
			SQL문장들2
		WHEN 조건3 THEN
			SQL문장들3
		ELSE
			SQL문장들4
	END CASE;

WHILE 문 : 조건식이 참인 동안에는 계속 같은 내용을 반복한다. 지정한 레이블로 가서 계속 실행하는 ITERATE 문과 지정한 레이블을 빠져나가는 LEAVE 문을 함께 사용할 수 있다.
	WHILE 문의 기본 형식 :
	WHILE <조건식> DO
		SQL문장들
	END WHILE;
	// ITERATE[레이블] : 지정한 레이블로 가서 계속 진행한다. (CONTINUE와 비슷한 역할. 반복문을 계속 진행한다)
	// LEAVE[레이블] : 지정한 레이블을 빠져나간다. 즉, WHILE 문이 종료된다. (BREAK와 비슷한 역할. 반복문을 빠져나간다)

동적 SQL 문 : 미리 SQL 문을 준비한 후에 필요할 때 실행하는 것이다. PREPARE는 SQL 문을 준비만 해놓고, EXECUTE는 준비한 SQL 문을 실행한다. 실행 후에는 DEALLOCATE PREPARE로 문장을 해제해야 한다.
	// PREPARE 문에서는 ?로 향후에 입력될 값을 비워 놓고, EXECUTE에서 USING으로 ?에 값을 전달할 수 있다.

일반 SQL에서 변수는 @변수명으로 지정하는데 별도의 선언은 없어도 된다. 스토어드 프로시저에서 변수는 DECLARE로 선언한 후에 사용해야 한다.

table(테이블) : 표 형태로 구성된 2차원 구조로 열(column)과 행(row)으로 구성되어 있다.
	// 테이블의 전체 이름은 데이터베이스_이름.테이블_이름 형식으로 표현
	// 테이블을 만들기 전에 설계를 먼저 해야 한다. 테이블 설계는 테이블 이름, 열 이름, 데이터 형식, 기본 키 등을 설정하는 것을 말한다.
	// SELECT * FROM market_db.member;
	// SELECT * FROM member;
	// 데이터베이스 이름을 생략하면 USE 문으로 지정해 놓은 데이터베이스가 자동으로 선택된다. 현재 선택된 데이터베이스가 market_db이므로 두 쿼리는 동일한 것이 된다. SELECT 문에서 테이블 이름은 원칙적으로 데이터베이스_이름.테이블_이름 형식을 사용해야 하지만 대부분 테이블_이름만 사용한다.

데이터베이스 생성하기 :
	DROP DATABASE IF EXISTS market_db; // DROP DATABASE는 market_db를 삭제하는 문장이다.
	CREATE DATABASE market_db; // 데이터베이스를 새로 만든다.

CREATE TABLE : 테이블을 생성하는 SQL로, 테이블 이름, 열 이름, 데이터 형식 등을 지정한다.

GUI(Graphical User Interface) : 윈도우에서 진행하는 작업을 의미
	GUI에서 테이블을 생성하는 방식 :
	기본 키는 PK 부분을 체크
	NOT NULL은 NN 부분을 체크
	UNSIGNED는 UN 부분을 체크
	자동 증가는 AI 부분을 체크

`(백틱) : 테이블 이름이나 열 이름을 묶을 때 사용

Primary key - Foreign key(기본 키 - 외래 키) : 두 테이블이 일대다로 연결되는 관계로 기본 키 - 외래 키 관계를 맺으면 오류가 없는 데이터가 된다. 기본 키가 있는 테이블을 기준 테이블, 외래 키가 있는 테이블을 참조 테이블이라고 한다.

PK(Primary Key) : 기본 키. 각 행을 구분하는 유일한 열. 기본 키에 입력되는 값은 중복될 수 없으며, NULL 값이 입력될 수 없다. 1개만 지정해야 한다. 기본키로 설정한 열이 기준이 되어 오름차순으로 자동 정렬된다. 열 이름 뒤에 PRIMARY KEY를 붙여주면 기본 키로 설정된다.

constraint(제약조건) : 데이터의 무결성. 즉, 데이터의 결함을 없애기 위해 제한하는 조건

ADD CONSTRAINT : 제약조건을 추가하는 SQL 문

PRIMARY KEY Constraint(기본 키 제약조건) : 많은 행 데이터 중 특정 데이터를 구분할 수 있는 식별자. 기본 키(Primary key)를 지정하여 중복된 데이터가 입력되지 않도록 제한하는 제약조건이다.

DESCRIBE : 테이블 또는 뷰의 정보를 조회하는 SQL 문. 줄여서 DESC라고 써도 된다.

ALTER TABLE : 이미 만들어진 테이블을 수정하는 SQL 문. 테이블의 열 이름 변경, 새로운 열 정의, 열 삭제 등의 작업

기본 키는 별도의 이름이 없으며, DESCRIBE 명령으로 확인하면 그냥 PRI로만 나온다. 필요하다면 기본 키의 이름을 직접 지어줄 수 있다.

FOREIGN KEY Constraint(외래 키 제약조건) : 외래 키로 두 테이블 사이를 기본 키 - 외래 키 관계로 연결하여 무결한(오류가 없는) 데이터로 만드는 제약조건이다.
	외래 키의 형식 : FOREIGN KEY (열_이름) REFERENCES 기준_테이블(열_이름)

기본 키가 있는 테이블을 기준 테이블이라고 부르며, 외래 키가 있는 테이블을 참조 테이블이라고 부른다. 참조 테이블이 참조하는 기준 테이블의 열은 반드시 기본 키(Primary Key)나, 고유 키(Unique Key)로 설정되어 있어야 한다.

기본 키-외래 키 관계가 설정되면 기준 테이블의 열은 변경되거나 삭제되지 않는다. (참조 테이블의 데이터에 문제가 발생하기 때문)

ON UPDATE CASCADE : 기준 테이블의 기본 키를 변경하면 참조 테이블의 외래 키도 자동으로 변경되는 기능

ON DELETE CASCADE : 기준 테이블의 기본 키를 삭제하면 참조 테이블의 외래 키도 자동으로 삭제되는 기능

UNIQUE Constraint(고유 키 제약조건) : 중복되지 않는 유일한 값을 입력해야 하는 제약조건이다. 기본 키와는 다르게 NULL 값을 허용하며 여러 개를 설정해도 된다.

CHECK Constraint(체크 제약조건) : 입력되는 데이터를 점검하는 제약조건이다. 해당 열의 뒤에 CHECK(조건)을 추가하여 사용한다.

DEFAULT(기본값 정의) : 값을 입력하지 않았을 때 자동으로 입력될 값을 미리 지정해 놓는 제약조건이다. 기본값을 설정한 후에 default로 지정하면 설정된 기본값이 입력된다.

view(뷰) : 가상의 테이블. 테이블처럼 실제 데이터를 가지고 있지는 않고, SELECT 문으로 만들어져 있기 때문에 뷰에 접근하는 순간 SELECT가 실행되면서 그 결과가 화면에 출력되는 방식이다.
	뷰(실체 없음) -(연결됨)-> 테이블(실체 있음)
	// 테이블을 사용하지 않고 뷰를 사용하는 이유 : 1. 보안에 도움이 된다. 2. 긴 SQL 문을 간략하게 만들 수 있다.

CREATE VIEW : 뷰를 생성하는 SQL 문

ALTER VIEW : 뷰를 수정하는 SQL 문

DROP VIEW : 뷰를 삭제하는 SQL 문

WITH CHECK OPTION : 뷰에 설정된 범위에 따라 그에 해당되는 값만 입력되도록 지정하는 SQL 문

Full Table Scan : 테이블의 모든 데이터를 훑어서 원하는 데이터를 찾아내는 것을 말한다.

index(인덱스) : 테이블에서 데이터를 빠르게 조회할 수 있도록 도와주는 도구. 책 뒤의 '찾아보기'와 비슷한 개념이다.
	인덱스의 장점 : SELECT 문으로 검색하는 속도가 매우 빨라진다. 그 결과 컴퓨터의 부담이 줄어들어서 결국 전체 시스템의 성능이 향상된다.
	인덱스의 단점 : 인덱스도 공간을 차지해서 데이터베이스 안에 추가적인 공간이 필요하다. 처음에 인덱스를 만드는 데 시간이 오래 걸릴 수 있다.
	// 데이터베이스에 인덱스를 생성해 놓아도, 인덱스를 사용해서 검색하는 것이 빠를지 아니면 전체 테이블을 검색하는 것이 빠를지 MySQL이 알아서 판단한다. 만약 인덱스를 사용하지 않는다면 사용하지도 않는 찾아보기를 만든 것이므로 쓸데없이 공간을 낭비한 셈이다.

Clustered Index(클러스터형 인덱스) : 기본 키(Primary Key)로 지정하면 자동으로 생성되고 테이블당 1개만 만들 수 있다. 해당 열을 기준으로 가동 정렬된다.

Secondary Index(보조 인덱스) : 고유 키(Unique)로 지정하면 자동으로 생성되며, 테이블당 여러 개를 만들 수 있다. 자동 정렬을 되지 않는다.

Balanced tree(B-tree) : 균형 트리. 자료 구조에서 범용적으로 사용되는 데이터 구조. 클러스터형 인덱스와 보조 인덱스 모두 내부적으로 이 균형 트리로 만들어진다.

Node(노드) : 균형 트리 구조에서 데이터가 저장되는 공간. 가장 상위부터 루트 노드, 중간 노드, 리프 노드로 구분된다.

Page(페이지) : MySQL에서는 노드를 페이지라고 부른다. 16Kbyte(16384byte) 크기를 가진 최소한의 저장 단위로, 데이터를 1건만 입력해도 1개 페이지가 필요하다.

페이지 분할 : 데이터 입력 시 입력할 페이지에 공간이 없는 경우 새로운 페이지를 준비해서 데이터를 나누는 작업. 페이지 분할이 일어날수록 MySQL이 느려지기 때문에 성능에 나쁜 영향을 줄 수 있다.

Index Scan(인덱스 검색) : 클러스터형 또는 보조 인덱스를 이용해서 데이터를 검색하는 것. 속도는 인덱스를 사용하지 않았을 때보다 빠르고, 클러스터형 인덱스가 보조 인덱스보타 조금 더 빠르다. (Non-Unique Key Lookup)

CREATE INDEX : 인덱스를 직접 생성하는 구문. 보조 인덱스가 생성된다.
	열_이름 = 값은 열의 해당하는 결과만 출력

DROP INDEX : CREATE INDEX 문으로 생성한 인덱스를 제거한다. 기본 키, 고유 키로 자동 생성된 인덱스는 DROP INDEX로 제거하지 못한다.

SHOW INDEX : 테이블에 어떤 인덱스가 설정되어 있는지 확인하는 SQL 문

SHOW TABLE STATUS : 테이블에 생성된 인덱스의 크기를 확인하는 SQL 문

Simple Secondary Index(단순 보조 인덱스) : 중복을 허용하는 보조 인덱스. CREATE INDEX 문으로 생성한다.

Unique Secondary Index(고유 보조 인덱스) : 중복을 허용하지 않는 보조 인덱스. CREATE UNIQUE INDEX 문으로 생성한다.

ANALYZE TABLE : 인덱스를 생성한 후 ANALYZE TABLE 문을 실행해서 테이블을 분석/처리해줘야 실제로 적용된다.

Execution Plan(실행 계획) : MySQL 워크벤치에서 SQL 실행 시 인덱스의 사용 여부를 확일할 수 있다.

// 인덱스를 효과적으로 사용하는 방법
	1. 인덱스는 열 단위에 생성한다.
	2. WHERE 절에서 사용되는 열에 인덱스를 만들어야 한다.
	3. WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
	4. 데이터의 중복이 높은 열은 인덱스를 만들어도 별 효과가 없다.
	5. 클러스터형 인덱스는 테이블당 하나만 생성할 수 있다.
	6. 사용하지 않는 인덱스는 제거한다.

stored procedure(스토어드 프로시저) : MySQL 에서 제공하는 프로그래밍 기능. 쿼리 문의 집합으로 어떤 동작을 일괄 처리하기 위한 용도로 사용한다. SQL을 묶는 개념 외에 연산식, 조건문, 반복문 등을 사용할 수도 있다.
	스토어드 프로시저의 구조 :
	DELIMITER $$
	CREATE PROCEDURE 스토어드_프로시저_이름()
	BEGIN
		이 부분에 SQL 프로그래밍 코딩
	END $$ // 스토어드 프로시저 종료
	DELIMITER ; // 종료 문자를 다시 세미콜론(;)으로 변경
	CALL 스토어드_프로시저_이름(); // 스토어드 프로시저 실행

BEGIN ~ END : 스토어드 프로시저는 BEGIN ~ END 사이에 코드를 구현한다.

DELIMITER : MySQL에서는 기본적으로 세미콜론(;)을 구분자로 사용하는데, 스토어드 프로시저 안에 있는 SQL의 끝에도 세미콜론을 사용하면 혼동될 수 있으므로 구분자를 $$, ##, %%, && 등으로 바꿔 사용하는 것이 좋다. (다른 기호와 중복될 수 있으므로 기호 2개를 연속해서 사용하는 것이 좋다)

CALL : 작성된 스토어드 프로시저를 실행(호출)하는 명령문

CREATE : 데이터베이스 개체를 생성할 때 사용하는 예약어

DROP : 데이터베이스 개체를 삭제할 때 사용하는 예약어

입력 매개변수 : 스토어드 프로시저에 값을 전달한다. 형식은 IN 구문을 사용한다.

출력 매개변수 : 스토어드 스포시저에서 처리된 결과를 돌려받는다. 형식은 OUT 구문을 사용한다.

stored function(스토어드 함수) : MySQL에서 제공하는 다양한 내장 함수 외에 사용자가 직접 만들어서 사용하는 함수

RETURNS : 스토어드 함수에서 반환할 값의 데이터 형식을 미리 지정할 때 사용한다.

RETURN : 스토어드 함수에서 값을 반환할 때 사용한다.

cursor(커서) : 테이블의 모든 행을 한 행씩 처리할 때 사용하는 방식. DECLARE로 선언하며, 그 내용은 SELECT 문이다.

endOfRow : 행의 끝을 파악하기 위한 변수로 endOfRow를 준비한다. 행의 끝에 다다르면 TRUE 값인지 체크하는 방식을 사용한다.

trigger(트리거) : 테이블에서 DML 문(Inset, Update, Delete 등)의 이벤트가 발생할 때 자동으로 실행하는 프로그래밍 기능. 사용자가 추가 작업을 잊어버리는 실수를 방지해준다.

외부 라이브러리 : 파이썬에서 제공하지 않는 기능을 외부 개발자가 만들어서 제공하는 기능. 파이썬을 설치한 후에 필요한 라이브러리를 추가로 설치하면 된다.

PyMySQL : 파이썬을 MySQL과 연결시켜주는 대표적인 외부 라이브러리

IDLE(Integrated Development and Learning Environment) : 파이썬을 개발하는 통합 개발 환경

대화형 모드 : 소스 코드 한 줄을 입력하고 Enter 키를 누르면 바로 실행하는 방식

스크립트 모드 : 여러 줄을 코딩한 후 한 번에 실행하는 방식

compiled language(컴파일 언어) : 소스 코드를 실행 가능한 기계어로 일괄 번역한 후에 번역이 완료된 파일(*.exe, *.class 등)이 실행되는 언어. 대표적인 컴파일 언어로 C, C++, 자바 등이 있다.

interpreted language(스크립트 언어, 인터프리트 언어) : 소스 코드를 한 줄씩 읽어 바로 실행되는 언어. 따라서 별도의 실행 파일이 생성되지 않는다. 대표적인 스크립트 언어로 파이썬, 자바스크립트, 펄 등이 있다.

import pymysql : SQL과 파이썬을 연동하기 위해 사용하는 명령

commit(커밋) : 변경한 내용을 확실하게 저장하는 것. 커밋 전의 데이터는 데이터베이스에 임시 저장된 상태이다.

fetchone() : 파이썬에서 SELECT 문으로 조회한 데이터를 한 행씩 가져오기 위해 사용하는 함수. 모든 행에 한꺼번에 접근할 때는 fetchall()을 사용한다.

GUI(Graphical User Interface) : 그래픽 사용자 인터페이스. 그래픽으로 화면을 제공하여 사용자가 편리하게 작업할 수 있는 환경. 파이썬을 통해 윈도우에 출력되는 GUI 응용 프로그램을 작성할 수 있다.

tkinter : 파이썬에서 GUI 관련 모듈을 제공해주는 표준 윈도우 라이브러리, 윈도우 화면이 필요할 때는 꼭 써줘야 한다.

widget(위젯) : 윈도우에 나오는 라벨, 버튼, 프레임, 리스트 박스 등을 통합해서 지칭하는 용어

[Output] 패널의 의미
	초록색 체크 표시 : SQL이 정상적으로 실행되었다는 의미
	빨간색 X 표시 : SQL에 오류가 발생했다는 의미
	# : 실행한 SQL의 순번. 실행한 SQL이 여러 개라면 1, 2, 3... 순서로 증가
	Time : SQL을 실행한 시각이 표시
	Action : 실행된 SQL이 표시
	Message : SELECT 문이 조회된 행의 개수가 나옴. 만약 오류 발생 시에는 오류 번호 및 오류 메시지가 표시
	Duration/Fetch : Duration은 SQL 문이 실행되는 데 걸린 시간(초), Fetch는 데이터베이스에서 가져온 시간(초)